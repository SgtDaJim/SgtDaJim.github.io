<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Ro$es Echo</title><link href="http://roses-echo.com/" rel="alternate"></link><link href="http://roses-echo.com/feeds/all.atom.xml" rel="self"></link><id>http://roses-echo.com/</id><updated>2017-08-14T18:10:00+08:00</updated><entry><title>运维之路 - 根据crontab时间语法推算任务上一次的执行时间</title><link href="http://roses-echo.com/articles/2017/Aug/14/road-to-ops-calculate-last-startup-time-according-to-cron-expression/" rel="alternate"></link><published>2017-08-14T18:10:00+08:00</published><updated>2017-08-14T18:10:00+08:00</updated><author><name>Ro$es</name></author><id>tag:roses-echo.com,2017-08-14:/articles/2017/Aug/14/road-to-ops-calculate-last-startup-time-according-to-cron-expression/</id><summary type="html">&lt;p&gt;根据Linux的crontab中的时间语法(cronExpression)，推算出任务的上一次执行时间。&lt;/p&gt;</summary><content type="html">&lt;hr /&gt;
&lt;p&gt;&lt;em&gt;本脚本同时收录在了我自己的github仓库中：&lt;a href="https://github.com/SgtDaJim/ops_script/blob/master/base_on_python2/get_last_startup_time.py"&gt;get_last_startup_time&lt;/a&gt;，拉下来后可以当成模块导入使用。&lt;/em&gt;&lt;br /&gt;
&lt;em&gt;&lt;a href="https://github.com/SgtDaJim/ops_script"&gt;ops_script&lt;/a&gt; 这个github仓库中是我平时写的工作中用到的一些脚本。欢迎大家使用、改进和提出建议。&lt;/em&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h1&gt;背景&lt;/h1&gt;
&lt;p&gt;在我的运维工作中，出现过这么一个需求：&lt;br /&gt;
crontab中的定时任务开始执行和执行结束，都会往数据库里面写日志。此时要对任务进行监控，根据日志判断任务的执行情况（是否按时执行、执行是否超时……）。所以，就需要对定时任务的执行时间进行推算了。在Baidu和Google上都搜索过，没有相关的轮子，大多都是对计划任务的下一次执行时间进行推算，没有对上一次推算的。。&lt;br /&gt;
于是，就有了这么一个轮子。&lt;/p&gt;
&lt;h1&gt;代码&lt;/h1&gt;
&lt;p&gt;实际上代码分为两个部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对cronExpression进行解析&lt;/li&gt;
&lt;li&gt;推算上一次执行时间&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而其中的第一部分是我在Google上找到的。。&lt;br /&gt;
如有侵权风险，请及时通知处理！！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本代码基于Python 2.7编写&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;代码：  &lt;/p&gt;
&lt;div class="gist"&gt;
    &lt;script src='https://gist.github.com/f5d067a90cbf6a40346c6dccffa22f02.js'&gt;&lt;/script&gt;
    &lt;noscript&gt;
        &lt;pre&gt;&lt;code&gt;#!/usr/bin/env python
# -*- coding:utf-8 -*-
# Author: Ro$es

import re
import time
import datetime


def parse_crontab_time(conf_string):
    """
    解析crontab时间配置参数
    Args:
    conf_string  配置内容(共五个值：分 时 日 月 周) 
                取值范围 分钟:0-59 小时:0-23 日期:1-31 月份:1-12 星期:0-6(0表示周日)
    Return:
    crontab_range	 list格式，分 时 日 月 周 五个传入参数分别对应的取值范围
    """
    time_limit = ((0, 59), (0, 23), (1, 31), (1, 12), (0, 6))
    crontab_range = []
    clist = []
    conf_length = 5
    tmp_list = conf_string.split(' ')

    # 这个循环，把字符串中的非空字符串保留下来
    for val in tmp_list:
        # print val
        if len(clist) == conf_length:
            break
        # 只保留非空字符串
        if val:
            clist.append(val)

    # 防止读入配置的列数不正确
    if len(clist) != conf_length:
        return -1, 'config error with [%s]' % conf_string
    cindex = 0
    for conf in clist:
        res_conf = []
        res_conf = parse_conf(conf, ranges=time_limit[cindex], res=res_conf)
        if not res_conf:
            return -1, 'config error whith [%s]' % conf_string
        crontab_range.append(sorted(res_conf))
        cindex = cindex + 1
    return 0, crontab_range


def parse_conf(conf, ranges=(0, 100), res=list()):
    """解析crontab 五个时间参数中的任意一个"""
    # 去除空格，再拆分
    conf = conf.strip(' ').strip(' ')
    conf_list = conf.split(',')
    other_conf = []
    number_conf = []
    for conf_val in conf_list:
        if match_cont(PATTEN['number'], conf_val):
            # 记录拆分后的纯数字参数
            number_conf.append(conf_val)
        else:
            # 记录拆分后纯数字以外的参数，如通配符 * , 区间 0-8, 及 0－8/3 之类
            other_conf.append(conf_val)

    if other_conf:
        # 处理纯数字外各种参数
        for conf_val in other_conf:
            for key, ptn in PATTEN.items():
                if match_cont(ptn, conf_val):
                    res = PATTEN_HANDLER[key](val=conf_val, ranges=ranges, res=res)
    if number_conf:

        if len(number_conf) &gt; 1 or other_conf:
            # 纯数字多于1，或纯数字与其它参数共存，则数字作为时间列表
            res = handle_nlist(val=','.join(number_conf), ranges=ranges, res=res)
        else:
            # 只有一个纯数字存在，则数字为时间 间隔
            res = handle_num(val=number_conf[0], ranges=ranges, res=res)
    return res

def match_cont(patten, cont):
    """
    正则匹配(精确符合的匹配)
    Args:
        patten 正则表达式
        cont____ 匹配内容
    Return:
        True or False
    """
    res = re.match(patten, cont)
    if res:
        return True
    else:
        return False
 
def handle_num(val, ranges=(0, 100), res=list()):
    """处理纯数字"""
    val = int(val)
    if val &gt;= ranges[0] and val &lt;= ranges[1]:
        res.append(val)
    return res
 
def handle_nlist(val, ranges=(0, 100), res=list()):
    """处理数字列表 如 1,2,3,6"""
    val_list = val.split(',')
    for tmp_val in val_list:
        tmp_val = int(tmp_val)
        if tmp_val &gt;= ranges[0] and tmp_val &lt;= ranges[1]:
            res.append(tmp_val)
    return res
 
def handle_star(val, ranges=(0, 100), res=list()):
    """处理星号"""
    if val == '*':
        tmp_val = ranges[0]
        while tmp_val &lt;= ranges[1]:
            res.append(tmp_val)
            tmp_val = tmp_val + 1
    return res
 
def handle_starnum(val, ranges=(0, 100), res=list()):
    """星号/数字 组合 如 */3"""
    tmp = val.split('/')
    # mod on 2017/6/14 
    # 在0分或者0点时任务依然执行。
    if ranges[1] == 59 or ranges[1] == 23 or ranges[1] == 6:
        res.append(0)
    #####
    val_step = int(tmp[1])
    if val_step &lt; 1:
        return res
    val_tmp = int(tmp[1])
    while val_tmp &lt;= ranges[1]:
        res.append(val_tmp)
        val_tmp = val_tmp + val_step
    return res
 
def handle_range(val, ranges=(0, 100), res=list()):
    """处理区间 如 8-20"""
    tmp = val.split('-')
    range1 = int(tmp[0])
    range2 = int(tmp[1])
    tmp_val = range1
    if range1 &lt; 0:
        return res
    while tmp_val &lt;= range2 and tmp_val &lt;= ranges[1]:
        res.append(tmp_val)
        tmp_val = tmp_val + 1
    return res

def handle_rangedv(val, ranges=(0, 100), res=list()):
    """处理区间/步长 组合 如 8-20/3 """
    tmp = val.split('/')
    range2 = tmp[0].split('-')
    val_start = int(range2[0])
    val_end = int(range2[1])
    val_step = int(tmp[1])
    if (val_step &lt; 1) or (val_start &lt; 0):
        return res
    val_tmp = val_start
    while val_tmp &lt;= val_end and val_tmp &lt;= ranges[1]:
        res.append(val_tmp)
        val_tmp = val_tmp + val_step
    return res

def get_last_startup_time(cron = "25-50 17 14-27 6-9 *"):
    """
    计算计划任务上一个启动时间。
    Args:
        cron: 计划任务的启动周期
    Returns:
        last_startup_time: 上一个启动时间的timestamp
    """



    # 现在时间
    datetime_now = datetime.datetime.now()
    now = time.strftime("%M-%H-%d-%m-%w",time.localtime(time.time()))
    # print time.strftime("%Y-%m-%d-%H-%M",time.localtime(time.time()))
    # print datetime_now
    now = now.split("-")
    now_minite = int(now[0])
    now_hour = int(now[1])
    now_day = int(now[2])
    now_month = int(now[3])
    now_weekday = int(now[4])
    # print now_minite, now_hour, now_day, now_month, now_weekday

    # 算出计划任务的所有启动时间
    res, desc = parse_crontab_time(cron)
    if res == 0:
        cron_time = desc
    else: # res不为0即存在出错，输出错误信息
        print(desc)
        sys, exit(-1)
    
    small_month = [2,4,6,9,11]

    cron_minite = cron_time[0]
    cron_hour = cron_time[1]
    cron_day = cron_time[2]
    cron_month = cron_time[3]
    cron_weekday = cron_time[4]

    # print cron_minite
    # print cron_hour
    # print cron_day
    # print cron_month
    # print cron_weekday

    run_minite = int()
    run_hour = int()
    run_day = int()
    run_month = int()
    run_weekday = int()
    run_year = int()

    is_today = False # 今天是否执行任务标记

    year = time.strftime("%Y",time.localtime(time.time())) # 年份

    hour_push_front = False
    day_push_front = False
    month_push_front = False
    year_push_front = False

    # 计算分钟部分
    if now_hour in cron_hour and now_day in cron_day and now_month in cron_month: # 当月份、日期、小时都不在执行周期范围内时，分钟值毫无疑问是list的最后一个值
        if now_minite &lt; cron_minite[0]: # 当现在的分钟比执行周期的分钟第一个值还要小，则上一次执行的分钟是执行周期分钟中的最后一个值
            run_minite = cron_minite[-1]
            # 此时，若现在小时在执行周期中，那么上次执行的小时就是现在小时往前推一位
            hour_push_front = True
        else:
            for i in range(len(cron_minite)):
                if cron_minite[i] &lt;= now_minite:
                    run_minite = cron_minite[i]
    else:
        run_minite = cron_minite[-1]

    # 计算小时部分
    if now_day in cron_day and now_month in cron_month: # 当日期、月份都不在执行周期范围内时，小时值毫无疑问是list的最后一个值
        if now_hour &lt; cron_hour[0]: # 当现在的小时比执行周期的小时第一个值还要小，则上一次执行的小时是执行周期小时中的最后一个值
            run_hour = cron_hour[-1]
            # 此时，若现在日期在执行周期中，那么上次执行的日期就是现在日期往前推一位
            day_push_front = True
        else:
            for i in range(len(cron_hour)):
                if cron_hour[i] &lt;= now_hour:
                    run_hour = cron_hour[i] # 当前小时不在执行周期中时，不用推前。
                    if run_hour == now_hour and hour_push_front : # 若当前小时在执行周期中，而且处理分钟时导致小时往前推
                        run_hour = cron_hour[cron_hour.index(run_hour)-1]
                        if cron_hour.index(run_hour) == len(cron_hour) - 1: # 若小时从执行周期的小时List的第一位变为最后一位时，日期也要往前推
                            day_push_front = True
    else:
        run_hour = cron_hour[-1]
                
    # 计算日期部分
    if now_month in cron_month: # 当月份不在执行周期范围内时，日期值毫无疑问是list的最后一个值
        if now_day &lt; cron_day[0]: # 当现在的日期比执行周期的日期第一个值还要小，则上一次执行的日期是执行周期日期中的最后一个值
            run_day = cron_day[-1]
            # 此时，若现在月份在执行周期中，那么上次执行的月份就是现在月份往前推一位
            month_push_front = True
        else:
            for i in range(len(cron_day)):
                if cron_day[i] &lt;= now_day:
                    run_day = cron_day[i] # 当前日期不在执行周期中时，不用推前。
                    if run_day == now_day and day_push_front : # 若当前日期在执行周期中，而且处理小时时导致日期往前推
                        run_day = cron_day[cron_day.index(run_day)-1]
                        if cron_day.index(run_day) == len(cron_day) - 1: # 若日期从执行周期的日期List的第一位变为最后一位时，月份也要往前推
                            month_push_front = True
    else:
        run_day = cron_day[-1]
    
    # 计算月份部分
    if now_month &lt; cron_month[0]: # 当现在的月份比执行周期的小时第一个值还要小，则上一次执行的小时是执行周期小时中的最后一个值
        run_month = cron_month[-1]
        # 此时，若现在日期在执行周期中，那么上次执行的日期就是现在日期往前推一位
        year_push_front = True
    else:
        for i in range(len(cron_month)):
            if cron_month[i] &lt;= now_month:
                run_month = cron_month[i] # 当前小时不在执行周期中时，不用推前。
                if run_month == now_month and month_push_front : # 若当前小时在执行周期中，而且处理分钟时导致小时往前推
                    run_month = cron_month[cron_month.index(run_month)-1]
                    if cron_month.index(run_month) == len(cron_month) - 1: # 若小时从执行周期的小时List的第一位变为最后一位时，月份也要往前推
                        year_push_front = True

    # 计算年份
    if year_push_front:
        run_year = int(year) - 1
    else:
        run_year = year

    time_str = "%s-%s-%s-%s-%s" % (run_year, run_month, run_day, run_hour, run_minite)
    # print time_str

    # 计算星期
    if len(cron_weekday) != 7: # 当每周执行的天数不是7天时，星期的设置与月份、日期的设置是"或"的关系

        hour_push_front = False
        weekday_push_front = False

        # 找出距离今天最近的上一个执行任务的星期值
        now_weekday = int(time.strftime("%w",time.localtime(time.time()))) # 今天星期几
        # 计算分钟部分
        if now_hour in cron_hour and now_weekday in cron_weekday: # 当月份、日期、小时都不在执行周期范围内时，分钟值毫无疑问是list的最后一个值
            if now_minite &lt; cron_minite[0]: # 当现在的分钟比执行周期的分钟第一个值还要小，则上一次执行的分钟是执行周期分钟中的最后一个值
                run_minite = cron_minite[-1]
                # 此时，若现在小时在执行周期中，那么上次执行的小时就是现在小时往前推一位
                hour_push_front = True
            else:
                for i in range(len(cron_minite)):
                    if cron_minite[i] &lt;= now_minite:
                        run_minite = cron_minite[i]
        else:
            run_minite = cron_minite[-1]

        # 计算小时部分
        if now_weekday in cron_weekday: # 当日期、月份都不在执行周期范围内时，小时值毫无疑问是list的最后一个值
            if now_hour &lt; cron_hour[0]: # 当现在的小时比执行周期的小时第一个值还要小，则上一次执行的小时是执行周期小时中的最后一个值
                run_hour = cron_hour[-1]
                # 此时，若现在日期在执行周期中，那么上次执行的日期就是现在日期往前推一位
                weekday_push_front = True
            else:
                for i in range(len(cron_hour)):
                    if cron_hour[i] &lt;= now_hour:
                        run_hour = cron_hour[i] # 当前小时不在执行周期中时，不用推前。
                        if run_hour == now_hour and hour_push_front : # 若当前小时在执行周期中，而且处理分钟时导致小时往前推
                            run_hour = cron_hour[cron_hour.index(run_hour)-1]
                            if cron_hour.index(run_hour) == len(cron_hour) - 1: # 若小时从执行周期的小时List的第一位变为最后一位时，日期也要往前推
                                weekday_push_front = True
        else:
            run_hour = cron_hour[-1]

        if now_weekday &lt; cron_weekday[0]:
            run_weekday = cron_weekday[-1]
        else:
            for i in range(len(cron_weekday)):
                if cron_weekday[i] &lt;= now_weekday:
                    run_weekday = cron_weekday[i]
                    if run_weekday == now_weekday and weekday_push_front : # 若当前小时在执行周期中，而且处理分钟时导致小时往前推
                        run_weekday = cron_weekday[cron_weekday.index(run_weekday)-1]

        # print run_weekday
        # 计算run_weekday是几号
        run_weekday_date = datetime_now - datetime.timedelta(days=(now_weekday-run_weekday) % 7)
        # 将星期设置与月份日期设置所得到的上一个执行时间对比，
        run_weekday_date = datetime.datetime.strftime(run_weekday_date, "%Y-%m-%d")
        run_weekday_date = datetime.datetime.strptime("%s-%s-%s" % (run_weekday_date, run_hour, run_minite), "%Y-%m-%d-%H-%M")
        time_str_date = datetime.datetime.strptime(time_str, "%Y-%m-%d-%H-%M")
        # print run_weekday_date
        # print time_str_date

        # 若从星期设置算出的执行时间比从月份、日期设置算出的执行时间更靠近今天，那么从星期设置算出的执行时间就是上个执行时间
        if run_weekday_date &gt; time_str_date:
            # print u"上一个执行时间为： %s" % (run_weekday_date)
            last_startup_time = time.mktime(run_weekday_date.timetuple())
            # print last_startup_time
        else:
            # print u"上一个执行时间为： %s" % (time_str_date)
            last_startup_time = time.mktime(time_str_date.timetuple())
            # print last_startup_time
    
    else:
        # print u"上一个执行时间为： %s" % (datetime.datetime.strptime(time_str, "%Y-%m-%d-%H-%M"))
        last_startup_time = time.mktime(datetime.datetime.strptime(time_str, "%Y-%m-%d-%H-%M").timetuple())
        
    return last_startup_time

#crontab时间参数各种写法 的 正则匹配
PATTEN = {
    #纯数字
    'number':'^[0-9]+$',
    #数字列表,如 1,2,3,6
    'num_list':'^[0-9]+([,][0-9]+)+$',
    #星号 *
    'star':'^\*$',
    #星号/数字 组合，如 */3
    'star_num':'^\*\/[0-9]+$',
    #区间 如 8-20
    'range':'^[0-9]+[\-][0-9]+$',
    #区间/步长 组合 如 8-20/3
    'range_div':'^[0-9]+[\-][0-9]+[\/][0-9]+$'
    #区间/步长 列表 组合，如 8-20/3,21,22,34
    #'range_div_list':'^([0-9]+[\-][0-9]+[\/][0-9]+)([,][0-9]+)+$'
}
#各正则对应的处理方法
PATTEN_HANDLER = {
    'number':handle_num,
    'num_list':handle_nlist,
    'star':handle_star,
    'star_num':handle_starnum,
    'range':handle_range,
    'range_div':handle_rangedv
}

if __name__ == "__main__":
    last_startup_time = get_last_startup_time("*/5 * * * *")
    print "Now: %s " % time.strftime("%m-%d %H:%M",time.localtime(time.time()))
    print "Timestamp of last startup time: %s " % last_startup_time
    print "In readable way: %s " % time.strftime("%m-%d %H:%M",time.localtime(last_startup_time))&lt;/code&gt;&lt;/pre&gt;
    &lt;/noscript&gt;
&lt;/div&gt;
&lt;h1&gt;测试效果&lt;/h1&gt;
&lt;p&gt;&lt;img alt="test" src="http://blogpictures-1252239032.cosgz.myqcloud.com/road-to-ops-cron-exp/1.png" /&gt;&lt;/p&gt;</content><category term="Linux"></category><category term="Ops"></category><category term="crontab"></category><category term="Python"></category><category term="code"></category></entry><entry><title>运维之路 - 运维原则与奇技淫巧[持续更新]</title><link href="http://roses-echo.com/articles/2017/Aug/07/road-to-ops-principle-and-tricks/" rel="alternate"></link><published>2017-08-07T18:30:02+08:00</published><updated>2017-08-07T18:30:02+08:00</updated><author><name>Ro$es</name></author><id>tag:roses-echo.com,2017-08-07:/articles/2017/Aug/07/road-to-ops-principle-and-tricks/</id><summary type="html">&lt;p&gt;本文章内容是我在日常工作中学习、摸索出来的一些经验。这些东西不是什么很高深的知识，很多人都早已烂熟于心。但我还是希望po出来，自己留个印记，也能让没注意过这些小点的人得到帮助。&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;strong&gt;现总计35条&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;做改动前做备份，无论多小的修改，都要做备份,因为备份是救命用的。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;做改动之前，先小范围测试，百分之一万确定没有任何问题时，再全范围修改。（此处可以参考版本发布流程规范）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在执行命令或者其他操作时，&lt;strong&gt;前后三思&lt;/strong&gt;，做好最坏打算，同时做好回滚准备。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在执行别人给的命令和操作时，先粘贴到别的地方看清楚，有没有错误，确定没有错误再执行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在查问题时，首先要想到查看日志。（没有日志？那就提前创造日志，别等出了事才知道慌。）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;处理技术问题的基本思路:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;怎么发现问题的&lt;/li&gt;
&lt;li&gt;怎么处理的&lt;/li&gt;
&lt;li&gt;影响多大&lt;/li&gt;
&lt;li&gt;怎么预防/避免   &lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;做出改动前，先认真考虑影响。直接改动的影响是什么？（业务影响、维护影响等）影响面广、影响重要应用的，请求多人确认；影响面小的，直接干。不能确定影响的，找人当面询问。（最低限度发邮件）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;凡事有交代，件件有着落，事事有回音。&lt;/strong&gt;（做运维如此，做人更应如此。）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;善用md5sum，可以快速找出哪些文件是不一样的。（特别是用Ansible对比多台机器上的配置文件时，非常方便直观）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查看mongodb运行状态  &lt;code&gt;mongostat&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ss(Socket Statistics的缩写)命令可以用来获取 socket统计信息，此命令输出的结果类似于 netstat输出的内容，但它能显示更多更详细的 TCP连接状态的信息，且比 netstat 更快速高效。&lt;br /&gt;
&lt;code&gt;ss -s&lt;/code&gt; 输出统计信息。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在zabbix server上运行zabbix_get，可以执行一个key。这样可以检查key是否设置正常。&lt;br /&gt;
&lt;code&gt;zabbix_get -s host/IP [-p 端口] -k key&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;善用screen，防止断网或者其他突发情况时，正在ssh上做的东西被中断导致严重后果！！
    &lt;code&gt;screen -R 名称&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安装PHP扩展时，可以选择使用PHP自带PECL扩展库安装。&lt;br /&gt;
&lt;a href="https://pecl.php.net/"&gt;PECL&lt;/a&gt;&lt;br /&gt;
&lt;a href="http://php.net/manual/zh/install.pecl.pear.php"&gt;pecl命令&lt;/a&gt;  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;nginx -t&lt;/code&gt;  检测配置文件语法错误，同时会显示主配置文件路径&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;nginx -s reload&lt;/code&gt; 工作过程：&lt;br /&gt;
    master进程检查配置文件是否正确。若错误，则返回错误信息,使用原来的配置继续工作；若正确，则启动新的worker进程,这些worker使用新的配置文件，新的请求也会分发到新的worker;旧的worker在处理完已分配的旧的请求后，就会被关闭。在这个过程，nginx的工作完全不受影响。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;python 连接数据库时，为了能重复使用cursor，避免在多次连接数据库上花费大量时间，可以将数据库的连接做成class。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;curl -I&lt;/code&gt; 可以输出http header，-s 静默模式，不输出进度表&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当机器无端端ssh连不上，但机器存活时，可以检查cpu和内存情况，然后再考虑ssh服务情况。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;zabbix中端口监控，type应该选active，使监控更加准确。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在修改crontab时，尽量跳到该用户下，使用crontab -e命令进行修改。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在shell中，冒号“:”可以当占位符使用。（与Python的“pass”相同）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Zabbix的日志监控&lt;br /&gt;
    Zabbix会跟踪日志的大小、最后的修改时间，有时会有inode号或者indexes号。Zabbix将这些数据保存在数据库中。当Zabbix分析文件时，会检查这些数据，判断日志进行过最新修改后已经被分析过了。如果（最新修改时间已经改变，而且根据日志的大小判断上一次分析到的地方，从那个地方开始）有新的部分没有分析，就会接着分析，满足条件时触发trigger。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;logtail&lt;/code&gt; 分析日志，并记录下分析到日志的哪个地方。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;sh -x 脚本名&lt;/code&gt;  可以在运行脚本时实现shell脚本逐条语句的跟踪。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;zgrep&lt;/code&gt; 可以不解压日志直接抓关键字&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;统计每分钟日志数
    &lt;code&gt;awk '{a[$2]++}END{for(i in a){print i" "a[i]}}'&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;centos中，nginx做转发时，记得修改SELinux配置。
    &lt;code&gt;setsebool -P httpd_can_network_connect 1&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当遇到4xx问题时，先考虑文件是否存在，然后考虑nginx配置是否正确。遇到5xx问题时，先考虑后端不返回。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在ssh时，提示permission denied(publickey)，其中一个点是可以尝试留意下.ssh/config中的内容。有时候这里会出问题。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;tar命令中， -C 参数意思是change to directory，可以做到跳到某目录然后打包该目录下所有文件的效果。&lt;br /&gt;
&lt;code&gt;tar -C ~/test/111/ -zcvf 123.tar.gz ./&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;logrotate中，create是新建一个日志文件，copytruncate是复制文件，再把原文件清空&lt;br /&gt;
    所以对nginx日志使用create时，要nginx -s reload，让nginx重新识别日志文件，防止日志无法写入&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;nginx在处理请求时，当有多个配置中，使用相同域名和相同端口，则访问域名时，nginx将请求发给default server（在listen字段加default）。当没设定default server时，若配置都在同一个配置文件中，请求则发给第一个配置；若在不同配置文件中，则按ascii码，找最前的配置文件。当然，listen字段中，同ip同端口只能有一个设定为default server。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;php-fpm的process_control_timeout参数应该设置为适当的值。php-fpm在reload时，process_control_timeout过小，会导致请求处理时间不够，出现502错误。当process_control_timeout的值过大时，空闲的fastcgi进程关闭，正在处理请求的进程则继续处理，若处理速度过慢，则会导致fastcgi进程不够而导致请求大量堆积。（所以迫切需要重启php-fpm的，还是把机器下流量，然后php-fpm restart吧。）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用CDN时，当大量CDN节点进行回源，将会对源服务器造成巨大的压力。此时，可以选择与CDN运营商沟通（如果是自建CDN就自己处理），只让少量（2、3台都可以了）的CDN节点进行回源，然后其他CDN节点到那些已经回源的节点上进行更新。这样源站的压力就会大大减轻。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;------------未完待续----------------&lt;/p&gt;</content><category term="Linux"></category><category term="Ops"></category></entry><entry><title>Linux学习笔记 - Linux软件防火墙iptables</title><link href="http://roses-echo.com/articles/2017/Aug/01/linux-note-linux-software-firewall-iptables/" rel="alternate"></link><published>2017-08-01T10:13:37+08:00</published><updated>2017-08-01T10:13:37+08:00</updated><author><name>Ro$es</name></author><id>tag:roses-echo.com,2017-08-01:/articles/2017/Aug/01/linux-note-linux-software-firewall-iptables/</id><summary type="html">&lt;p&gt;iptables的介绍与使用。&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;em&gt;参考资料：《循序渐进Linux第二版》&lt;/em&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;相关资料：     &lt;br /&gt;
&lt;a href="http://www.jianshu.com/p/c2aee2ff7bd8"&gt;iptables详解 - 简书&lt;/a&gt;     &lt;br /&gt;
&lt;a href="http://www.361way.com/icmp-type/1186.html"&gt;icmp-type对应表 - 运维之路&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;防火墙分为封包过滤式防火墙（Packet Filter）、应用层网关防火墙（Application-Level Gateway）两种。&lt;br /&gt;
iptables属于封包过滤式防火墙。  &lt;br /&gt;
iptables是Linux系统内嵌的一个防火墙软件，它继承在系统内核中，因此执行效率非常高。&lt;/p&gt;
&lt;p&gt;iptables中有3中表选项：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;管理本机数据进出的filter表&lt;/li&gt;
&lt;li&gt;管理防火墙内部主机的NAT表&lt;/li&gt;
&lt;li&gt;改变不同包以及包头内容的mangle表。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;filter&lt;/code&gt;表中内置了INPUT、OUTPUT和FORWARD链。（默认使用）（最常用）&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;链&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;INPUT&lt;/td&gt;
&lt;td&gt;主要对外部数据包进入Linux系统进行信息过滤&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;OUTPUT&lt;/td&gt;
&lt;td&gt;主要对内部Linux系统所要发送的数据包进行信息过滤&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;FORWARD&lt;/td&gt;
&lt;td&gt;将外面过来的数据包传递到内部计算机中&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;nat&lt;/code&gt;表中内置PREROUTING、POSTROUTING和OUTPUT链。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;链&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;PREROUTING&lt;/td&gt;
&lt;td&gt;在数据包刚刚到达防火墙时，根据需要改变它的目的地址&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;POSTROUTING&lt;/td&gt;
&lt;td&gt;在包就要离开防火墙之前改变其源地址&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;OUTPUT&lt;/td&gt;
&lt;td&gt;改变本地产生的包的目的地址&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mangle&lt;/code&gt;表中内置PREROUTING、POSTROUTING、OUTPUT、INPUT和FORWARD链。（不常用）&lt;/p&gt;
&lt;p&gt;当数据包进入Linux主机前，首先经过iptables的过滤。iptables将数据包与表中规则&lt;strong&gt;按顺序&lt;/strong&gt;对比，检查是否满足规则条件，然后执行动作。&lt;/p&gt;
&lt;p&gt;iptables工作顺序示意图：  &lt;br /&gt;
&lt;img alt="iptables工作顺序" src="http://roses-echo.com/images/linux-note-linux-software-firewall-iptables/1.png" /&gt;&lt;/p&gt;
&lt;p&gt;列出filter表的规则：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; iptables -t filter -L -n
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;清空所有规则：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; iptables -F
 iptables -X
 iptables -Z
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;-F 清空指定表中所有链的规则&lt;/li&gt;
&lt;li&gt;-X 删除使用者自定义的表&lt;/li&gt;
&lt;li&gt;-Z 将数据包计数器清零&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;将filter表中INPUT的预设规则改为DROP&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; iptables -P INPUT DROP
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="iptables" src="http://roses-echo.com/images/linux-note-linux-software-firewall-iptables/2.png" /&gt;&lt;/p&gt;
&lt;p&gt;将来自10.10.10.1的数据包丢弃&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; iptables -t filter -A INPUT -s 10.10.10.1 -j DROP
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="iptables" src="http://roses-echo.com/images/linux-note-linux-software-firewall-iptables/3.png" /&gt;&lt;br /&gt;
&lt;img alt="iptables" src="http://roses-echo.com/images/linux-note-linux-software-firewall-iptables/4.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注：只有在设置tcp或udp规则时，才能使用--sport或--dport参数。&lt;/strong&gt;&lt;/p&gt;
&lt;h4&gt;iptables规则练习&lt;/h4&gt;
&lt;p&gt;&lt;a href="https://www.centos.bz/2012/08/iptables-exercises/"&gt;iptables练习题 - Linux运维日志&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注：在CentOS 7.x后默认使用firewalld了。相关资料如下：&lt;/strong&gt; &lt;br /&gt;
&lt;a href="http://www.firewalld.org/"&gt;firewalld: Home&lt;/a&gt;  &lt;br /&gt;
&lt;a href="https://fedoraproject.org/wiki/FirewallD/zh-cn#.E4.BD.BF.E7.94.A8_FirewallD_.E6.9E.84.E5.BB.BA.E5.8A.A8.E6.80.81.E9.98.B2.E7.81.AB.E5.A2.99"&gt;使用firewalld - Fedora&lt;/a&gt;     &lt;br /&gt;
&lt;a href="http://www.centoscn.com/CentOS/help/2015/0208/4667.html"&gt;CentOS 7 firewalld使用简介&lt;/a&gt;&lt;/p&gt;</content><category term="Linux"></category><category term="CentOS"></category><category term="iptables"></category><category term="firewalld"></category></entry><entry><title>主机与VMware的虚拟机互相传送文件时，临时文件的存放位置</title><link href="http://roses-echo.com/articles/2017/Aug/01/the-location-of-temp-files-created-by-sending-files-with-vmware-tools/" rel="alternate"></link><published>2017-08-01T10:13:02+08:00</published><updated>2017-08-01T10:13:02+08:00</updated><author><name>Ro$es</name></author><id>tag:roses-echo.com,2017-08-01:/articles/2017/Aug/01/the-location-of-temp-files-created-by-sending-files-with-vmware-tools/</id><summary type="html">&lt;p&gt;妈妈再也不用怕我虚拟机的硬盘空间被传送文件的副本占用过度了~&lt;/p&gt;</summary><content type="html">&lt;h2&gt;虚拟机与主机的文件传送&lt;/h2&gt;
&lt;p&gt;众所周知，VMware虚拟机与主机之间可以通过vmware-tools发送文件。 &lt;br /&gt;
而在发送文件时，被传送的文件会先保存到目的主机的一个临时目录中，然后把临时目录的该文件复制到目的主机中需要被传送到的目录。  &lt;br /&gt;
例如，在我的Kali Linux虚拟机中有一个txt文档：        &lt;br /&gt;
&lt;img alt="1" src="http://blogpictures-1252239032.cosgz.myqcloud.com/the-location-of-t.../1.png" /&gt;    &lt;br /&gt;
现在把这个123.txt，复制到主机的桌面：  &lt;br /&gt;
&lt;img alt="2" src="http://blogpictures-1252239032.cosgz.myqcloud.com/the-location-of-t.../2.png" /&gt;      &lt;br /&gt;
其实这中间有个两个文件发送的过程： &lt;br /&gt;
&lt;strong&gt;虚拟机中的文件发送到临时目录&lt;/strong&gt;  &lt;br /&gt;
&lt;strong&gt;临时目录中文件复制到桌面&lt;/strong&gt;    &lt;/p&gt;
&lt;h2&gt;如何验证呢？&lt;/h2&gt;
&lt;p&gt;其实当我们从虚拟机中发送一个较大的文件时，就可以看到这两个过程了，因为会有进度条显示。    &lt;/p&gt;
&lt;h2&gt;那么临时目录在哪呢？&lt;/h2&gt;
&lt;p&gt;经过观察和搜索，  &lt;br /&gt;
&lt;strong&gt;在Windows主机中，临时目录的位置是：&lt;code&gt;C:\Users\使用账户\AppData\Local\Temp\vmware-账户名称\VMwareDnD&lt;/code&gt;&lt;/strong&gt;   &lt;br /&gt;
&lt;img alt="3" src="http://blogpictures-1252239032.cosgz.myqcloud.com/the-location-of-t.../3.png" /&gt;         &lt;/p&gt;
&lt;p&gt;在这些随即名称的文件夹中，就可以找到我们发送的文件。      &lt;br /&gt;
&lt;img alt="4" src="http://blogpictures-1252239032.cosgz.myqcloud.com/the-location-of-t.../4.png" /&gt;        &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;而在Linux主机中，临时目录的位置是：&lt;code&gt;/tmp/VMwareDnD&lt;/code&gt;和 &lt;code&gt;账户目录/.cache/vmware/drag_and_drop&lt;/code&gt;&lt;/strong&gt;    &lt;br /&gt;
为什么说有两个呢？  &lt;br /&gt;
先查看下&lt;code&gt;/tmp/VMwareDnD&lt;/code&gt;：   &lt;br /&gt;
&lt;img alt="5" src="http://blogpictures-1252239032.cosgz.myqcloud.com/the-location-of-t.../5.png" /&gt;        &lt;/p&gt;
&lt;p&gt;可以发现目录下确实有临时文件，但都是符号链接。    &lt;br /&gt;
而真正的文件所在目录，是&lt;code&gt;账户目录/.cache/vmware/drag_and_drop&lt;/code&gt;。  &lt;img alt="6" src="http://blogpictures-1252239032.cosgz.myqcloud.com/the-location-of-t.../6.png" /&gt;          &lt;/p&gt;
&lt;p&gt;这样，临时文件目录就很清楚了。    &lt;/p&gt;
&lt;h2&gt;得知临时文件的目录，有什么用？&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;用处大了！&lt;/strong&gt;  &lt;br /&gt;
通过分析文件的传送过程，我们可以得知：&lt;strong&gt;目的主机上保存了两份需要发送的文件！&lt;/strong&gt;   &lt;br /&gt;
这样就造成了容量的大量浪费。   &lt;br /&gt;
所以我们&lt;strong&gt;必须按时清理临时文件目录，避免容量浪费。&lt;/strong&gt;   &lt;br /&gt;
在Windows上，大数字或者CCleaner这些软件能扫描到这个缓存目录文件并自动清理。 &lt;br /&gt;
但Linux上呢？    &lt;br /&gt;
只能手动找目录，写脚本自动清理了。  &lt;/p&gt;</content><category term="VMware"></category><category term="套路"></category></entry><entry><title>解决注册Google账号时提示该号码无法用于进行验证的方法</title><link href="http://roses-echo.com/articles/2017/Aug/01/solve-google-validation-phone-number-problem/" rel="alternate"></link><published>2017-08-01T10:10:27+08:00</published><updated>2017-08-01T10:10:27+08:00</updated><author><name>Ro$es</name></author><id>tag:roses-echo.com,2017-08-01:/articles/2017/Aug/01/solve-google-validation-phone-number-problem/</id><summary type="html">&lt;p&gt;绕过“该号码无法用于进行验证”的提示。&lt;/p&gt;</summary><content type="html">&lt;p&gt;在注册google账号时，不少人会碰到，在给出合法，而且从来没注册过google账号的手机号码进行短信验证时，却提示“该号码无法用于进行验证”。&lt;/p&gt;
&lt;p&gt;如图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="validate" src="http://roses-echo.com/images/solve-google-validation-phone-number-problem/1.png" /&gt;&lt;/p&gt;
&lt;p&gt;嗨呀。。是不是很气。。&lt;/p&gt;
&lt;p&gt;连新申请的阿里小号，都有这种提示，特别无语。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;重点来了&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决方法：手机安装google服务框架，下载gmail(FQ什么的在大陆是肯定需要了)，在gmail里面申请google账号，这时填写在PC浏览器上用的手机号码，就不会提示无法验证了。。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;做法很简单，就是安装google框架有点麻烦而已。&lt;/p&gt;</content><category term="套路"></category><category term="Google"></category></entry><entry><title>2017-3-31有感</title><link href="http://roses-echo.com/articles/2017/Apr/01/2017-3-31-thought/" rel="alternate"></link><published>2017-04-01T00:00:21+08:00</published><updated>2017-04-01T00:00:21+08:00</updated><author><name>Ro$es</name></author><id>tag:roses-echo.com,2017-04-01:/articles/2017/Apr/01/2017-3-31-thought/</id><summary type="html">&lt;p&gt;阶级是一直存在的。&lt;br /&gt;
无论再怎么不承认，它都不会消失。  &lt;br /&gt;
有些人的生活不好，不是因为他们不努力去改变 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;阶级是一直存在的。&lt;br /&gt;
无论再怎么不承认，它都不会消失。  &lt;br /&gt;
有些人的生活不好，不是因为他们不努力去改变，而是即使有这个能力，有这个想法，环境和遭遇都会迫使你屈服，而你却无可奈何。    &lt;br /&gt;
你没得选！   &lt;br /&gt;
对不起，是我太年轻。   &lt;br /&gt;
听了一晚上的故事，让我意识到我现在觉得枯燥乏味的生活，在他人眼中可能是梦寐以求，可望却不可即的海市蜃楼。    &lt;br /&gt;
也许，这就是命运吧。      &lt;/p&gt;</content></entry><entry><title>Linux学习笔记 - Linux下软件的安装与管理</title><link href="http://roses-echo.com/articles/2017/Mar/03/linux-note-software-installation-and-managing/" rel="alternate"></link><published>2017-03-03T00:00:00+08:00</published><updated>2017-03-03T00:00:00+08:00</updated><author><name>Ro$es</name></author><id>tag:roses-echo.com,2017-03-03:/articles/2017/Mar/03/linux-note-software-installation-and-managing/</id><summary type="html">&lt;p&gt;编译、RPM、yum和二进制安装的介绍和使用。&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;em&gt;参考资料：《循序渐进Linux第二版》&lt;/em&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;CentOS下软件安装方式主要有：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;* 源码编译安装
* RPM安装
* yum安装
* 二进制安装
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;源码安装&lt;/h2&gt;
&lt;p&gt;步骤：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. 下载解压源码
2. 分析安装平台环境（configure脚本）
3. 编译安装（make &amp;amp;&amp;amp; make install）
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注：在./configure时一定要注意使用--prefix参数指定安装目录（首选），或者在make &amp;amp;&amp;amp; make install时注意保存日志，方便日后管理软件。（主要是删除软件时好找位置）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;相关资料链接：&lt;a href="https://www.jisec.com/linux/90.html"&gt;Linux编译安装中configure、make和make install 命令详解 | 极安全-JiSec&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;RPM安装&lt;/h2&gt;
&lt;p&gt;RPM(Red Hat Package Manager)，Red Hat 软件包管理器，现已成为Linux平台下通用的软件包管理方式。
&lt;code&gt;.rpm&lt;/code&gt;结尾的软件包为RPM文件，包含了已经编译好的二进制可执行代码。
源码进行编译、安装、封装，成为RPM文件。&lt;/p&gt;
&lt;p&gt;优点：安装简单、方便。通过RPM安装的软件，会记录软件的安装信息，方便日后的查询、升级和卸载。
缺点：对操作系统环境的依赖很大。&lt;/p&gt;
&lt;p&gt;RPM包封装格式有两种：RPM（.rpm）、SRPM（.src.rpm ）。&lt;/p&gt;
&lt;p&gt;RPM安装时若出现依赖错误，要先安装依赖软件，然后继续安装需要的软件。&lt;/p&gt;
&lt;p&gt;常用参数：
安装时：&lt;code&gt;-ivh&lt;/code&gt; 安装，显示详细信息并使用"#"符号表现安装过程。
查询：&lt;code&gt;-ql 安装后包名&lt;/code&gt; 显示软件包安装后的文件列表&lt;br /&gt;
&lt;img alt="rpm" src="http://roses-echo.com/images/linux-note-software-installation-and-managing/1.png" /&gt;&lt;/p&gt;
&lt;h2&gt;yum安装&lt;/h2&gt;
&lt;p&gt;yum(yellowdog updater modified)，配合互联网即可实现软件的便捷安装和自动升级。
实质：指定远程的互联网主机上的RPM软件包，然后自动进行安装，同时解决各个软件之间的依赖关系。&lt;/p&gt;
&lt;h3&gt;不错的yum源&lt;/h3&gt;
&lt;p&gt;CentOS官方列出可供使用的软件库 &lt;a href="https://wiki.centos.org/zh/AdditionalResources/Repositories"&gt;可供 CentOS 使用的软件库&lt;/a&gt;&lt;br /&gt;
EPEL &lt;a href="https://fedoraproject.org/wiki/EPEL/zh-cn"&gt;EPEL wiki&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;二进制安装&lt;/h2&gt;
&lt;h3&gt;二进制压缩包安装&lt;/h3&gt;
&lt;p&gt;一般为&lt;code&gt;.tar.gz&lt;/code&gt;或&lt;code&gt;.bz2&lt;/code&gt;后缀，直接解压可用。&lt;/p&gt;
&lt;h3&gt;有安装脚本的软件包&lt;/h3&gt;
&lt;p&gt;解压后，目录下一般有安装脚本，名称类似&lt;code&gt;setup.sh&lt;/code&gt;或者&lt;code&gt;install&lt;/code&gt;等，赋予可执行权限后运行即可完成安装。&lt;/p&gt;</content><category term="Linux"></category><category term="CentOS"></category></entry><entry><title>Linux学习笔记 - Linux下常用命令</title><link href="http://roses-echo.com/articles/2017/Feb/28/linux-note-commonly-used-commands/" rel="alternate"></link><published>2017-02-28T00:00:00+08:00</published><updated>2017-02-28T00:00:00+08:00</updated><author><name>Ro$es</name></author><id>tag:roses-echo.com,2017-02-28:/articles/2017/Feb/28/linux-note-commonly-used-commands/</id><summary type="html">&lt;p&gt;日常使用频率最高的Linux命令。&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;em&gt;参考资料：《循序渐进Linux第二版》&lt;/em&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;系统管理与维护&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;ls&lt;/code&gt; 显示指定工作目录下的内容，列出工作目录所含的文件以及子目录。&lt;br /&gt;
&lt;img alt="shell" src="http://roses-echo.com/images/linux-note-commonly-used-commands/1.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;pwd&lt;/code&gt; 显示当前工作目录。&lt;br /&gt;
&lt;img alt="shell" src="http://roses-echo.com/images/linux-note-commonly-used-commands/2.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cd&lt;/code&gt; 改变当前工作目录。&lt;br /&gt;
&lt;img alt="shell" src="http://roses-echo.com/images/linux-note-commonly-used-commands/3.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;date&lt;/code&gt; 显示或修改系统日期时间。但只有超级用户才能设置时间。&lt;/p&gt;
&lt;p&gt;&lt;img alt="shell" src="http://roses-echo.com/images/linux-note-commonly-used-commands/4.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;passwd&lt;/code&gt; 设置用户密码。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;su&lt;/code&gt;  改变用户身份。&lt;br /&gt;
&lt;strong&gt;注：&lt;code&gt;su&lt;/code&gt;命令中使用&lt;code&gt;-&lt;/code&gt;参数可以加载相应用户下的环境变量。&lt;/strong&gt; 
&lt;strong&gt;如直接输入&lt;code&gt;su -&lt;/code&gt;，则会改为root身份，并且加载root的环境变量。&lt;/strong&gt;
&lt;strong&gt;若不加载root的环境变量，某些指令可能无法执行，会提示"command not found"&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;clear&lt;/code&gt; 清屏。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;man&lt;/code&gt; 显示指定指令的帮助信息。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;who&lt;/code&gt; 显示目前登录到系统的用户。&lt;br /&gt;
&lt;img alt="shell" src="http://roses-echo.com/images/linux-note-commonly-used-commands/5.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;w&lt;/code&gt; 显示登录到系统的用户信息。&lt;br /&gt;
&lt;img alt="shell" src="http://roses-echo.com/images/linux-note-commonly-used-commands/6.png" /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一行显示当前系统时间、系统运行时间、登录用户数和系统平均负载（1min、5min、15min内系统负载情况）。&lt;/li&gt;
&lt;li&gt;USER 登录系统的用户&lt;/li&gt;
&lt;li&gt;TTY 用户使用的TTY&lt;/li&gt;
&lt;li&gt;FROM 用户登录的远程主机的IP或主机名&lt;/li&gt;
&lt;li&gt;LOGIN@ 用户登录的日期时间&lt;/li&gt;
&lt;li&gt;IDLE 某个程序执行持续时间&lt;/li&gt;
&lt;li&gt;JCPU 终端上所有进程和紫禁城呢个使用系统的总时间&lt;/li&gt;
&lt;li&gt;PCPU 活动进程使用的系统时间&lt;/li&gt;
&lt;li&gt;WHAT 用户执行的进程名称和选项&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;uname&lt;/code&gt; 显示操作系统的相关信息。&lt;br /&gt;
&lt;img alt="shell" src="http://roses-echo.com/images/linux-note-commonly-used-commands/7.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;uptime&lt;/code&gt; 输出系统任务队列信息。  &lt;br /&gt;
&lt;img alt="shell" src="http://roses-echo.com/images/linux-note-commonly-used-commands/8.png" /&gt;&lt;br /&gt;
显示当前系统时间、系统运行时间、登录用户数和系统平均负载（1min、5min、15min内系统负载情况）。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;last&lt;/code&gt; 目前与过去登入系统的用户相关信息。（默认读取/var/log/wtmp，并把该文件记录的登入系统的用户名单全部显示出来）&lt;br /&gt;
&lt;img alt="shell" src="http://roses-echo.com/images/linux-note-commonly-used-commands/9.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;dmesg&lt;/code&gt; 显示开机信息。（保存在/var/log/dmesg）&lt;/p&gt;
&lt;p&gt;&lt;code&gt;free&lt;/code&gt; 显示系统内存状态&lt;br /&gt;
&lt;img alt="shell" src="http://roses-echo.com/images/linux-note-commonly-used-commands/10.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ps&lt;/code&gt; 显示系统进程在瞬间的运行状态&lt;/p&gt;
&lt;p&gt;&lt;code&gt;top&lt;/code&gt; 对系统处理器状态的实时监控，能够实时显示系统中各个进程的资源占用情况。&lt;br /&gt;
&lt;img alt="shell" src="http://roses-echo.com/images/linux-note-commonly-used-commands/11.png" /&gt;&lt;/p&gt;
&lt;h2&gt;文件管理与编辑&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;mkdir&lt;/code&gt; 创建目录&lt;/p&gt;
&lt;p&gt;&lt;code&gt;more&lt;/code&gt; 分屏显示较长文本文件。按enter显示文件下一行，按空格显示文件下一屏。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cat&lt;/code&gt; 将文件内容输出到标准输出。还可以用于合并文件。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;diff&lt;/code&gt; 逐行比较文本文件的差异；比较目录中相同文件名的文件。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;grep&lt;/code&gt; 根据自定字符串，搜索文件每一行。输出字符串所在行内容。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;rm&lt;/code&gt; 删除某个目录及其下的所有文件和子目录。（若为链接文件，则断开链接，源文件不变。）&lt;/p&gt;
&lt;p&gt;&lt;code&gt;touch&lt;/code&gt; 改变指定文件的访问时间和修改时间。若文件不存在，则创建文件。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ln&lt;/code&gt; 在文件或目录之间创建链接。（默认硬链接）&lt;/p&gt;
&lt;p&gt;&lt;code&gt;file&lt;/code&gt; 显示文件类型。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cp&lt;/code&gt; 将一个文件或目录复制到另一个文件或目录中。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;find&lt;/code&gt; 指定路径下查找指定文件。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;split&lt;/code&gt; 分割文档。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mv&lt;/code&gt; 将文件和目录重命名或将文件从一个目录移动到另一个目录。&lt;/p&gt;
&lt;h2&gt;压缩与解压&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;zip/unzip&lt;/code&gt; 压缩、解压。默认压缩文件后缀为".zip"。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;gzip/gunzip&lt;/code&gt; 压缩、解压。默认压缩文件后缀为“.gz”&lt;/p&gt;
&lt;p&gt;&lt;code&gt;bzip2/bunzip&lt;/code&gt; 压缩、解压。默认压缩文件后缀为“.bz2”&lt;/p&gt;
&lt;p&gt;&lt;code&gt;tar&lt;/code&gt; 归档、打包工具。（不压缩）（可以加参数进行压缩）&lt;/p&gt;
&lt;p&gt;&lt;code&gt;dd&lt;/code&gt; 转换或复制文件，同时可以对设备进行备份。&lt;br /&gt;
&lt;strong&gt;注：of不能与if在同一个目录下，否则陷入死循环&lt;/strong&gt;
&lt;strong&gt;注：恢复目标分区时，一定要先卸载目标分区，恢复完成后再进行挂载。&lt;/strong&gt;
&lt;strong&gt;注：备份的分区和恢复的分区最好一致，恢复分区若大于备份分区，则浪费空间；否则提示空间不足。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cpio&lt;/code&gt; 通过重定向的方式将文件进行打包、备份、还原、恢复的工具。可以解压&lt;code&gt;.cpio&lt;/code&gt;或者&lt;code&gt;.tar&lt;/code&gt;结尾的文件。&lt;br /&gt;
&lt;strong&gt;注：cpio在打包、备份时用的是绝对路径，则恢复时会自动恢复到该绝对路径下。若使用相对路径，则会还原到相对路径。&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;磁盘管理与维护&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;df&lt;/code&gt; 检查Linux系统的磁盘空间占用情况。&lt;br /&gt;
&lt;img alt="shell" src="http://roses-echo.com/images/linux-note-commonly-used-commands/12.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;du&lt;/code&gt; 显示文件或目录所占用的磁盘空间情况。&lt;br /&gt;
&lt;img alt="shell" src="http://roses-echo.com/images/linux-note-commonly-used-commands/13.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;fsck&lt;/code&gt; 检查文件系统并尝试修复错误。&lt;br /&gt;
&lt;strong&gt;注：fsck修复某个文件系统时，这个文件系统对应的磁盘分区一定要处于卸载状态，磁盘分区在挂载状态下进行修复是极为不安全的，数据可能遭到破坏，也有可能损坏磁盘。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sync&lt;/code&gt; 强制把内存中的数据写回硬盘，以免数据的丢失。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;eject&lt;/code&gt; 退出抽取式设备，如光驱或磁盘。若设备已挂载，eject将先卸载设备，再退出设备。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mount/umount&lt;/code&gt; 挂载/卸载指定文件系统&lt;/p&gt;
&lt;h2&gt;网络设置与维护&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;ifconfig&lt;/code&gt; 配置网络或显示当前网络接口状态  &lt;br /&gt;
&lt;img alt="shell" src="http://roses-echo.com/images/linux-note-commonly-used-commands/14.png" /&gt;&lt;br /&gt;
**注：ifconfig配置的网卡信息在网卡或者机器重启后，所有配置失效，要配置永久生效，要修改网卡配置文件。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;scp&lt;/code&gt; secure copy，将文件或目录从一个Linux系统复制到另一个Linux系统。&lt;br /&gt;
scp传输数据使用了&lt;em&gt;SSH&lt;/em&gt;协议，保证了数据传输的安全。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;netstat&lt;/code&gt; 显示本机网络链接、运行端口和路由表等信息。 &lt;br /&gt;
&lt;img alt="shell" src="http://roses-echo.com/images/linux-note-commonly-used-commands/15.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;traceroute&lt;/code&gt; 显示网络数据包传输到指定主机的路径信息，追踪数据传输路由状况。&lt;strong&gt;（使用了ICMP协议）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;telnet&lt;/code&gt; 通过telnet协议与远程主机通信或获取远程主机对应端口的信息。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;wget&lt;/code&gt; 从网络上下载某个文件。&lt;/p&gt;</content><category term="Linux"></category><category term="CentOS"></category><category term="shell"></category></entry><entry><title>V2EX上关于如何优化CentOS服务器内存的讨论</title><link href="http://roses-echo.com/articles/2017/Feb/26/v2ex-improve-centos-memory-discuss/" rel="alternate"></link><published>2017-02-26T20:38:58+08:00</published><updated>2017-02-26T20:38:58+08:00</updated><author><name>Ro$es</name></author><id>tag:roses-echo.com,2017-02-26:/articles/2017/Feb/26/v2ex-improve-centos-memory-discuss/</id><summary type="html">&lt;p&gt;V站链接：&lt;a href="http://cn.v2ex.com/t/343252"&gt;请问后端和运维小伙伴们，你们都是如何优化 centos 服务器的内存 …&lt;/a&gt;&lt;/p&gt;</summary><content type="html">&lt;p&gt;V站链接：&lt;a href="http://cn.v2ex.com/t/343252"&gt;请问后端和运维小伙伴们，你们都是如何优化 centos 服务器的内存？&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;&lt;code&gt;@hl&lt;/code&gt; 的回复  &lt;/p&gt;
&lt;p&gt;Linux 内存不是用的越少越好， Centos7 版本以前，通常看到的内存 used 比较多是因为包含了 buffer 和 cache 占用 &lt;br /&gt;
Centos7 版本以后，内存 used 显示数值不包含 buffer 和 cache   &lt;/p&gt;
&lt;p&gt;Linux 中内存不用白不用，会尽可能的 cache 和 buffer 一些数据，以方便下次使用。 
但实际上这些内存大部分也是在应用需要的时候可以释放出来供应用使用。   &lt;/p&gt;
&lt;p&gt;大部分人在对 linux 做内存优化，都是简单的关闭不使用的服务，调整自己应用的参数来减少内存的占用 
因此我也仅通过最简单的方式来介绍下如何调整 &lt;/p&gt;
&lt;h1&gt;关闭服务&lt;/h1&gt;
&lt;p&gt;Centos7 版本以前可以通过 chkconfig --list 来查看服务列表 &lt;br /&gt;
找到当前 runlevel 下自启动的服务名&lt;br /&gt;
然后通过 chkconfig --level 3 service_name off 关闭指定 RUNLEVEL 下自启动服务 &lt;br /&gt;
重启后生效或者通过 /etc/init.d/servicce_name stop 的方式来实时生效。 &lt;/p&gt;
&lt;p&gt;Centos7 以后的版本需要通过
systemctl list-unit-files --type=service --state=enabled &lt;br /&gt;
查看自启动服务&lt;br /&gt;
通过 systemctl disable service_name 关闭启动 &lt;br /&gt;
通过 systemctl stop service_name 停止服务运行   &lt;/p&gt;
&lt;h1&gt;调整应用参数&lt;/h1&gt;
&lt;p&gt;这个部分需要了解自己启动的服务软件简单的工作原理和配置方法 
VPS 中安装的 LNMP 环境主要包含三个套件： Nginx, MySQL, php &lt;/p&gt;
&lt;h1&gt;Nginx&lt;/h1&gt;
&lt;p&gt;工作进程数量直接决定了 Nginx 对内存的占用，平均一个工作进程占用 10~40m 不等 &lt;br /&gt;
可通过配置文件中 worker_processes 指定 &lt;/p&gt;
&lt;h1&gt;MySQL&lt;/h1&gt;
&lt;p&gt;MySQL 比较复杂，大致可以从全局共享内存使用和线程独享内存使用两个方向入手 &lt;/p&gt;
&lt;p&gt;全局共享内存可理解为 MySQL 启动的时候就需要分配的全局内存使用 
比较明显的是可以调整以下几个参数（但不完全就是以下几个）
&lt;code&gt;key_buffer_size 
innodb_buffer_pool_size 
innodb_additional_memory_pool_size 
innodb_log_buffer_size 
query_cache_size&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;线程独享内存使用可以理解为每个到 MySQL 的链接都会分配一部分内存 
&lt;code&gt;read_buffer_size 
sort_buffer_size 
read_rnd_buffer_size 
tmp_table_size&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;除此之外 MySQL 还有灰常多的参数可以调整影响到内存的使用，可以参考官方文档了 &lt;/p&gt;
&lt;p&gt;以上列出的参数，也并不是调整了就有效果，因为 MySQL 还有一个重要的东西就是存储引擎   &lt;br /&gt;
常用的比如 InnoDB ， MyISAM 很多参数都是针对存储引擎的，比如你只使用 InnoDB,却调整了 MyISAM 的参数，那也是没有效果的 &lt;/p&gt;
&lt;h1&gt;php&lt;/h1&gt;
&lt;p&gt;由于本人没有搞过 php 所以具体也不清楚详细的调整 &lt;br /&gt;
php 没有运行在 nginx 下的 module ，所以大部分通过 php-fpm 的方式启动 &lt;br /&gt;
php-fpm 提供 fastcgi 的协议访问， nginx 再通过 fastcgi 反代到 php-fpm   &lt;/p&gt;
&lt;p&gt;所以这里的 php-fpm 也是一个多进程应用，也可以通过调整 php-fpm 的启动进程数量来达到控制内存占用的效果  &lt;/p&gt;
&lt;p&gt;以上这些都是从简单的方面来优化的，但还是那句话，一切看你时机的使用情况，这些参数不是越低越好 &lt;br /&gt;
比如 nginx 只给 1 个进程，php-fpm 只给一个进程，在你狂刷浏览器时就会发现你经常会遇到 502，503 错误 &lt;/p&gt;
&lt;p&gt;鉴于在题主是在放在 vps 中的小博客，实在不需要搞到太深度的调优。  如果想了解仍可去搜索一些相关的资料: &lt;br /&gt;
linux 内核参数调优 &lt;br /&gt;
linux io 队列调优 &lt;br /&gt;
nginx 如何通过编译安装精简模块 &lt;br /&gt;
php 编译安装 精简不必要模块 &lt;br /&gt;
mysql 编译安装精简存储引擎  &lt;/p&gt;</content><category term="V2EX"></category><category term="CentOS"></category><category term="内存优化"></category></entry><entry><title>2017-2-25有感</title><link href="http://roses-echo.com/articles/2017/Feb/25/2017-2-25-thought/" rel="alternate"></link><published>2017-02-25T00:00:00+08:00</published><updated>2017-02-25T00:00:00+08:00</updated><author><name>Ro$es</name></author><id>tag:roses-echo.com,2017-02-25:/articles/2017/Feb/25/2017-2-25-thought/</id><summary type="html">&lt;ul&gt;
&lt;li&gt;“你是xxx（某歌星/影星/球星等）的粉丝吗 …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;ul&gt;
&lt;li&gt;“你是xxx（某歌星/影星/球星等）的粉丝吗？”&lt;/li&gt;
&lt;li&gt;“是啊，我很喜欢他的（歌/电影）的啊。”&lt;/li&gt;
&lt;li&gt;“听说的最近（出轨了/分手了/离婚了）啊！”&lt;/li&gt;
&lt;li&gt;“哦，关我屁事。”&lt;/li&gt;
&lt;/ul&gt;</content></entry><entry><title>2017-2-20凌晨</title><link href="http://roses-echo.com/articles/2017/Feb/20/2017-2-20-midnight-thought/" rel="alternate"></link><published>2017-02-20T00:00:00+08:00</published><updated>2017-02-20T00:00:00+08:00</updated><author><name>Ro$es</name></author><id>tag:roses-echo.com,2017-02-20:/articles/2017/Feb/20/2017-2-20-midnight-thought/</id><summary type="html">&lt;p&gt;打游戏打到一点多&lt;br /&gt;
就上床玩手机&lt;br /&gt;
到两点&lt;br /&gt;
朋友突然问谁没睡&lt;br /&gt;
我打了个 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;打游戏打到一点多&lt;br /&gt;
就上床玩手机&lt;br /&gt;
到两点&lt;br /&gt;
朋友突然问谁没睡&lt;br /&gt;
我打了个“？”&lt;br /&gt;
结果朋友说不舒服，想去医院&lt;br /&gt;
我直接说等我换衣服，到他宿舍门口叫他。&lt;br /&gt;
现在3点49分&lt;br /&gt;
期间陪朋友看医生，打点滴，帮他倒水，付费，拿药&lt;br /&gt;
现在坐在他床边等他打点滴&lt;br /&gt;
想了很多东西&lt;br /&gt;
我想起我寒假口角炎的时候一个人坐那打点滴&lt;br /&gt;
药水很冷，很痛&lt;br /&gt;
而且没法上厕所&lt;br /&gt;
难受的一比&lt;br /&gt;
我很庆幸我朋友有我这个朋友&lt;br /&gt;
倒不是说我吹我自己&lt;br /&gt;
可是没我，他一个人估计麻烦到头晕&lt;br /&gt;
我相信如果是我不舒服&lt;br /&gt;
他也会帮我&lt;br /&gt;
毕竟这就是朋友  &lt;/p&gt;</content></entry><entry><title>动手配置Shadowsocks服务器端+TCP BBR</title><link href="http://roses-echo.com/articles/2017/Feb/19/install-ss-and-use-bbr-on-vps/" rel="alternate"></link><published>2017-02-19T00:00:00+08:00</published><updated>2017-02-19T00:00:00+08:00</updated><author><name>Ro$es</name></author><id>tag:roses-echo.com,2017-02-19:/articles/2017/Feb/19/install-ss-and-use-bbr-on-vps/</id><summary type="html">&lt;p&gt;Let's break the wa11.&lt;/p&gt;</summary><content type="html">&lt;p&gt;最近有人出一台kvm的主机，还有8个月租用时间。刚好我的搬瓦工也差不多到期，就接过来搭梯子了。&lt;br /&gt;
搬瓦工的ss是可以一键配置的。所以这次配置是真正意义上的第一次配置。  &lt;/p&gt;
&lt;p&gt;主机系统：CentOS 7&lt;/p&gt;
&lt;p&gt;用xshell连上了主机。&lt;br /&gt;
&lt;img alt="xshell" src="http://roses-echo.com/images/install-ss-and-use-bbr-on-vps1.png" /&gt;  &lt;/p&gt;
&lt;p&gt;Shadowsocks有多种语言的版本。Python、Go、Node.js等等，在github都可以找到。&lt;br /&gt;
在这里我选择安装Python版本的，因为Python版本已经发布到了PyPi社区了，安装起来很方便。&lt;br /&gt;
而CentOS中是自带了Python的。  &lt;/p&gt;
&lt;p&gt;&lt;img alt="xshell" src="http://roses-echo.com/images/install-ss-and-use-bbr-on-vps2.png" /&gt;  &lt;/p&gt;
&lt;p&gt;可是并没有安装pip，所以要先安装pip。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:::bash
yum install pip
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可是，问题出现了。  &lt;/p&gt;
&lt;p&gt;&lt;img alt="xshell" src="http://roses-echo.com/images/install-ss-and-use-bbr-on-vps3.png" /&gt;&lt;/p&gt;
&lt;p&gt;No package。。
谷歌了一下原来CentOS这类衍生的发行版的源存在内容更新滞后和没有扩展源的问题，要先安装扩展源EPEL。&lt;/p&gt;
&lt;p&gt;&lt;img alt="wiki" src="http://roses-echo.com/images/install-ss-and-use-bbr-on-vps4.png" /&gt;&lt;/p&gt;
&lt;p&gt;那就安装吧。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:::bash
yum install epel-release
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="xshell" src="http://roses-echo.com/images/install-ss-and-use-bbr-on-vps5.png" /&gt;&lt;/p&gt;
&lt;p&gt;先来查找下pip的package的名称是什么。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:::bash
yum search pip
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="xshell" src="http://roses-echo.com/images/install-ss-and-use-bbr-on-vps6.png" /&gt;&lt;/p&gt;
&lt;p&gt;因为系统中的python版本为2.x，那我就安装python2-pip。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:::bash
yum install python2-pip
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="xshell" src="http://roses-echo.com/images/install-ss-and-use-bbr-on-vps7.png" /&gt;&lt;/p&gt;
&lt;p&gt;这下可以安装shadowsocks了。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:::bash
pip install shadowsocks
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="xshell" src="http://roses-echo.com/images/install-ss-and-use-bbr-on-vps8.png" /&gt;&lt;/p&gt;
&lt;p&gt;安装完成。接下来配置shadowsocks。&lt;br /&gt;
shadowsocks有两种配置方法，一种是命令行配置，另一种是配置文件配置。&lt;br /&gt;
我使用了文件配置，个人感觉比较直观。  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:::bash
vi /etc/shadowsocks/config.json
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;{
  "server":"x.x.x.x", #vps的ip
  "server_port":2333, #服务器端口
  "local_address":"127.0.0.1", #本地地址
  "local_port":1080,  #本地代理端口
  "password":"xxxxx", #认证密码
  "timeout":5,        #超时时间，单位为秒
  "method":"aes-256-cfb" #加密方式，推荐使用aes-256-cfb
}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;写完保存。&lt;br /&gt;
然后执行命令&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:::bash
ssserver -c /etc/shadowsocks/config.json -d start
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;后台运行shadowsocks程序。&lt;/p&gt;
&lt;p&gt;&lt;img alt="xshell" src="http://roses-echo.com/images/install-ss-and-use-bbr-on-vps9.png" /&gt;&lt;/p&gt;
&lt;p&gt;服务端配置完成。&lt;br /&gt;
客户端看看是否能连接。&lt;/p&gt;
&lt;p&gt;&lt;img alt="ss" src="http://roses-echo.com/images/install-ss-and-use-bbr-on-vps10.png" /&gt;&lt;/p&gt;
&lt;p&gt;谷歌打不开。。&lt;br /&gt;
看看日志怎么回事&lt;/p&gt;
&lt;p&gt;&lt;img alt="ss" src="http://roses-echo.com/images/install-ss-and-use-bbr-on-vps11.png" /&gt;&lt;/p&gt;
&lt;p&gt;一堆timeout。。&lt;br /&gt;
配置过程应该是没问题的。。&lt;br /&gt;
想了想，好像是忘了在vps中开端口。。&lt;br /&gt;
试试把端口打开看看。&lt;br /&gt;
CentOS 7使用了firewalld防火墙。  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:::bash
firewall-cmd --zone=public --add-port=2333/tcp --permanent
firewall-cmd --zone=public --add-port=2333/udp --permanent
firewall-cmd --complete-reload
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;全部success。&lt;br /&gt;
再次打开谷歌看看。&lt;/p&gt;
&lt;p&gt;&lt;img alt="explore" src="http://roses-echo.com/images/install-ss-and-use-bbr-on-vps12.png" /&gt;&lt;/p&gt;
&lt;p&gt;成功。&lt;br /&gt;
shadowsocks算是配置完了。&lt;br /&gt;
看看在youtube上看视频速度如何。  &lt;/p&gt;
&lt;p&gt;打开youtube速度还是很快的。&lt;br /&gt;
点一个Carpool Karaoke看看。&lt;br /&gt;
清晰度切换到720P  &lt;/p&gt;
&lt;p&gt;&lt;img alt="youtube" src="http://roses-echo.com/images/install-ss-and-use-bbr-on-vps13.png" /&gt;&lt;/p&gt;
&lt;p&gt;看看统计信息。&lt;/p&gt;
&lt;p&gt;&lt;img alt="youtube" src="http://roses-echo.com/images/install-ss-and-use-bbr-on-vps14.png" /&gt;&lt;/p&gt;
&lt;p&gt;这速度。。难受。。&lt;/p&gt;
&lt;p&gt;最近BBR很火。&lt;br /&gt;
BBR是谷歌开发的TCP拥塞控制算法，目的就是要尽量跑满带宽，并且尽量不要有排队的情况。&lt;br /&gt;
最近这货已经被开源，提交到了Linux内核。现在更新到最新内核应该就能用上BBR。&lt;br /&gt;
那我也来试一试。&lt;br /&gt;
CentOS可以直接使用ELRepo Project上的最新内核。&lt;br /&gt;
CentOS 7执行命令：  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:::bash
rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org
rpm -Uvh http://www.elrepo.org/elrepo-release-7.0-2.el7.elrepo.noarch.rpm
yum --enablerepo=elrepo-kernel install kernel-ml -y
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="xshell" src="http://roses-echo.com/images/install-ss-and-use-bbr-on-vps15.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="xshell" src="http://roses-echo.com/images/install-ss-and-use-bbr-on-vps16.png" /&gt;&lt;/p&gt;
&lt;p&gt;新内核安装完成。&lt;br /&gt;
查查内核情况：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:::bash
egrep ^menuentry /etc/grub2.cfg | cut -f 2 -d \'
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="xshell" src="http://roses-echo.com/images/install-ss-and-use-bbr-on-vps17.png" /&gt;&lt;/p&gt;
&lt;p&gt;第一个就是最新的。&lt;br /&gt;
现在把引导文件中默认引导设为最新内核。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:::bash
grub2-set-default 0 # 0就是第一个内核，刚才看到的第一个
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后reboot，重启。  &lt;/p&gt;
&lt;p&gt;（新主机重启只要几十秒。。很恐怖）  &lt;/p&gt;
&lt;p&gt;看看内核  &lt;/p&gt;
&lt;p&gt;&lt;img alt="xshell" src="http://roses-echo.com/images/install-ss-and-use-bbr-on-vps18.png" /&gt;&lt;/p&gt;
&lt;p&gt;新内核美滋滋 ~&lt;/p&gt;
&lt;p&gt;接着把BBR打开。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:::bash
vi /etc/sysctl.conf
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在这个文件中加入两行：  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:::bash
net.core.default_qdisc = fq
net.ipv4.tcp_congestion_control = bbr
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;保存退出。&lt;/p&gt;
&lt;p&gt;&lt;img alt="xshell" src="http://roses-echo.com/images/install-ss-and-use-bbr-on-vps19.png" /&gt;&lt;/p&gt;
&lt;p&gt;然后&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:::bash
sysctl -p
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="xshell" src="http://roses-echo.com/images/install-ss-and-use-bbr-on-vps20.png" /&gt;&lt;/p&gt;
&lt;p&gt;现在BBR设置应该生效了。  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:::bash
lsmod | grep bbr
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="xshell" src="http://roses-echo.com/images/install-ss-and-use-bbr-on-vps21.png" /&gt;&lt;/p&gt;
&lt;p&gt;BBR正常启动了。&lt;br /&gt;
在用youtube测测速。。  &lt;/p&gt;
&lt;p&gt;&lt;img alt="xshell" src="http://roses-echo.com/images/install-ss-and-use-bbr-on-vps22.png" /&gt;&lt;/p&gt;
&lt;p&gt;好很多了。。。&lt;br /&gt;
这下看1080P就美滋滋了~  &lt;/p&gt;
&lt;h4&gt;以上配置方法都是谷歌的，绝无半点抄袭之意，如有意见，请联系提出。&lt;/h4&gt;
&lt;h4&gt;感谢谷歌，也感谢所有乐于分享的人。&lt;/h4&gt;</content><category term="VPS"></category><category term="Shadowsocks"></category><category term="SS"></category><category term="BBR"></category></entry><entry><title>推荐《吐槽大会》2017-02-12期</title><link href="http://roses-echo.com/articles/2017/Feb/12/tui-jian-tu-cao-da-hui-2017-02-12qi/" rel="alternate"></link><published>2017-02-12T00:00:00+08:00</published><updated>2017-02-12T00:00:00+08:00</updated><author><name>Ro$es</name></author><id>tag:roses-echo.com,2017-02-12:/articles/2017/Feb/12/tui-jian-tu-cao-da-hui-2017-02-12qi/</id><summary type="html">&lt;p&gt;本期的吐槽对象是唐国强老师&lt;br /&gt;
但这只是其中一个亮点&lt;br /&gt;
这期吐槽大会，估计是有稿子，但嘉宾不一定完全照搬稿子吐槽 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;本期的吐槽对象是唐国强老师&lt;br /&gt;
但这只是其中一个亮点&lt;br /&gt;
这期吐槽大会，估计是有稿子，但嘉宾不一定完全照搬稿子吐槽&lt;br /&gt;
李艾，王刚，唐国强的台词都有明显的锋利度，在突出一些事情&lt;br /&gt;
特别是唐国强&lt;br /&gt;
他的吐槽，并不是吐槽，而是在演讲，在阐述一些道理&lt;br /&gt;
虽然这有违“吐槽”二字，但却让我丝毫没有不舒适感&lt;br /&gt;
反而十分享受他的演讲&lt;br /&gt;
另外&lt;br /&gt;
王刚和唐国强真的是德高望重的老艺术家&lt;br /&gt;
举手投足都是戏&lt;br /&gt;
流露出了无穷无尽的演员经验和良好的职业素养&lt;br /&gt;
也许&lt;br /&gt;
这就是真正的人生如戏吧  &lt;/p&gt;
&lt;p&gt;&lt;img alt="唐国强图片1" src="http://roses-echo.com/images/唐国强图片1.png" /&gt;&lt;br /&gt;
&lt;img alt="唐国强图片2" src="http://roses-echo.com/images/唐国强图片2.png" /&gt;&lt;br /&gt;
&lt;img alt="王刚图片1" src="http://roses-echo.com/images/王刚图片1.png" /&gt;  &lt;/p&gt;</content></entry><entry><title>Linux学习笔记 - Linux运行机制与systemd的使用</title><link href="http://roses-echo.com/articles/2017/Jan/26/linux-note-linux-operation-mechanism-and-using-systemd/" rel="alternate"></link><published>2017-01-26T00:00:00+08:00</published><updated>2017-01-26T00:00:00+08:00</updated><author><name>Ro$es</name></author><id>tag:roses-echo.com,2017-01-26:/articles/2017/Jan/26/linux-note-linux-operation-mechanism-and-using-systemd/</id><summary type="html">&lt;p&gt;必知必会知识的其中之一。&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;em&gt;参考资料：《循序渐进Linux第二版》&lt;/em&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;em&gt;文章相关资料链接：&lt;/em&gt;&lt;br /&gt;
&lt;a href="https://www.ibm.com/developerworks/cn/linux/1407_liuming_init1/"&gt;浅析 Linux 初始化 init 系统，第 1 部分: sysvinit&lt;/a&gt;&lt;br /&gt;
&lt;a href="https://www.ibm.com/developerworks/cn/linux/1407_liuming_init2/"&gt;浅析 Linux 初始化 init 系统，第 2 部分: UpStart&lt;/a&gt;&lt;br /&gt;
&lt;a href="https://www.ibm.com/developerworks/cn/linux/1407_liuming_init3/"&gt;浅析 Linux 初始化 init 系统，第 3 部分: Systemd&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;init系统&lt;/h3&gt;
&lt;p&gt;Linux系统启动过程：&lt;br /&gt;
BIOS -&amp;gt; Linux引导程序将内核映像加载到内存，进行内核初始化 -&amp;gt; 启动PID为1的init进程&lt;br /&gt;
&lt;code&gt;init进程&lt;/code&gt;是系统的&lt;strong&gt;第一个进程&lt;/strong&gt;，负责产生其他所有的用户进程。&lt;br /&gt;
但仅仅将内核运行起来是毫无用途的，因此就需要一个系统能够定义、管理和控制init进程的行为，并且负责组织和运行许多独立的或相关的初始化工作，从而让系统进入一个用户设定的运行模式中，这个系统就是init系统。&lt;/p&gt;
&lt;p&gt;最早、最流行的init系统：sysvinit。RHEL 7.x/CentOS 7.x发行版本之前的系统中都采用sysvinit。&lt;br /&gt;
优点：概念简单清晰，主要依赖于Shell脚本。&lt;br /&gt;
缺点：一次一个串行地启动进程导致最大弱点：启动太慢。&lt;/p&gt;
&lt;p&gt;然后开发者进行改进，先后出现upstart和systemd这两个主要的新一代init系统。&lt;br /&gt;
以Ubuntu为代表的Linux发行版使用upstart。&lt;br /&gt;
RHEL 7.x/CentOS 7.x默认开始使用systemd。&lt;br /&gt;
upstart出现很早，systemd出现较晚，但发展更快，大有取代upstart的趋势。&lt;/p&gt;
&lt;h3&gt;sysvinit的runlevel和systemd的target&lt;/h3&gt;
&lt;p&gt;sysvinit用术语“runlevel”来定义系统运行级别。&lt;br /&gt;
通常有7种运行级别，在/etc/inittab文件中指定。&lt;br /&gt;
sysvinit通过检查/etc/inittab中是否含有“initdefault”项来启动一个默认的运行级别。
每个Linux发行版对运行级别的定义都不太一样。但0、1、6三个级别获得了共识：   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;0 表示关机模式  &lt;/li&gt;
&lt;li&gt;1 表示单用户模式，单用户模式下只有系统管理员可以登录  &lt;/li&gt;
&lt;li&gt;6 表示重启模式，也就是关闭所有运行的进程，然后重新启动系统&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另外4个在RHEL/CentOS发行版定义的含义：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;2 表示多用户模式，不支持文件共享，例如不支持NFS服务。这种模式&lt;strong&gt;不常用&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;3 表示完全的多用户模式，支持NFS服务。这是&lt;strong&gt;最常用&lt;/strong&gt;的用户模式，默认登录到系统的&lt;em&gt;字符界面&lt;/em&gt;。&lt;/li&gt;
&lt;li&gt;4 表示基本不用的用户模式，可以实现某些特定的登录请求。&lt;/li&gt;
&lt;li&gt;5 表示完全多用户模式，默认登录到X-Window系统，也就是图形界面。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;运行级别与init程序对应。init 1命令进入单用户模式，init 6命令进行重新启动。  &lt;/p&gt;
&lt;p&gt;在RHEL 7.x/CentOS 7.x版本中，采用systemd管理体系，runlevel被target取代，/etc/inittab也不再使用。&lt;br /&gt;
systemd中，默认target（相当于以前的默认运行级别）通过软链接来实现。&lt;/p&gt;
&lt;p&gt;查看运行级别与target的对应关系
&lt;code&gt;ll /lib/systemd/system/runlevel*.target&lt;/code&gt;
&lt;img alt="target" src="http://roses-echo.com/images/linux-note-linux-operation-mechanism-and-using-systemd/1.png" /&gt;    &lt;/p&gt;
&lt;p&gt;查看默认target
&lt;code&gt;ll /etc/systemd/system/default.target&lt;/code&gt;
&lt;img alt="target" src="http://roses-echo.com/images/linux-note-linux-operation-mechanism-and-using-systemd/2.png" /&gt;  &lt;/p&gt;
&lt;p&gt;将默认target修改为multi-user.target
&lt;code&gt;rm -rf /etc/systemd/system/default.target
ln -sf /lib/systemd/system/multi-user.target /etc/systemd/system/default.target&lt;/code&gt;
&lt;img alt="target" src="http://roses-echo.com/images/linux-note-linux-operation-mechanism-and-using-systemd/3.png" /&gt;  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在将默认target改为reboot.target后，重启系统后将会无限重启！&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;可以通过修改启动脚本，更改启动级别为1，将默认target修改回来。&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;系统关机过程&lt;/h3&gt;
&lt;p&gt;常用关机命令：init、shutdown、halt、reboot&lt;/p&gt;
&lt;h4&gt;shutdown&lt;/h4&gt;
&lt;p&gt;可以安全关闭Linux系统，必须由超级用户执行。&lt;br /&gt;
shutdown命令执行后，会以广播的形式通知正在系统中工作的所有用户，系统将在指定时间内关闭，请保存文件，停止作业，注销用户。此时login指令被冻结，新的用户不能登录。当所有用户从系统中注销或指定时间已到，shutdown就发送信号给init程序，要求init修改系统运行级别。如果shutdown指定参数是关机命令，那么执行init 0；如果shutdown指定重启，那么执行init 6。
&lt;code&gt;man shutdown&lt;/code&gt;
&lt;img alt="man" src="http://roses-echo.com/images/linux-note-linux-operation-mechanism-and-using-systemd/4.png" /&gt;&lt;/p&gt;
&lt;h4&gt;halt&lt;/h4&gt;
&lt;p&gt;最简单的关机命令，相当于shutdown -h。执行halt时，将终止所有应用程序，然后调用系统指令sync。&lt;br /&gt;
sync将所有内存信息通过文件系统写入硬盘，然后停止内核。&lt;br /&gt;
halt执行时，会先检测系统的运行级别。如果为0或者6，则立即关闭系统，否则调用shutdown来关闭系统。&lt;/p&gt;
&lt;h4&gt;reboot&lt;/h4&gt;
&lt;p&gt;执行过程与halt基本类似。不同的是reboot用于重启。&lt;/p&gt;
&lt;h4&gt;init&lt;/h4&gt;
&lt;p&gt;切换运行级别。0为关机，6为重启。&lt;/p&gt;
&lt;h3&gt;系统服务管理工具systemd&lt;/h3&gt;
&lt;p&gt;使用sysvinit和upstart的系统版本中，使用&lt;code&gt;/etc/rc.d/init.d/&lt;/code&gt;目录中的bash初始化脚本管理服务。&lt;br /&gt;
7.x中，启动脚本被&lt;em&gt;服务单元&lt;/em&gt;取代。服务单元以&lt;code&gt;“.service”&lt;/code&gt;结尾。  &lt;/p&gt;
&lt;p&gt;systemd在系统中是一个用户级的应用程序，配置文件在&lt;code&gt;/etc/systemd/&lt;/code&gt;下，配置工具命令位于&lt;code&gt;/bin&lt;/code&gt;、&lt;code&gt;/sbin&lt;/code&gt;，备份配置文件位于&lt;code&gt;/lib/systemd&lt;/code&gt;。可以通过&lt;code&gt;rpm -ql systemd&lt;/code&gt;查看所有文件的安装路径。&lt;/p&gt;
&lt;p&gt;systemd提供了一个非常强大的命令行工具systemctl，可以看作是service和chkconfig的组合体。&lt;br /&gt;
查看、启动、停止、重启、启用或者禁用系统服务，都可以通过systemctl来实现。&lt;br /&gt;
为了向后兼容，旧的service命令在CentOS 7.x中&lt;strong&gt;仍然可用&lt;/strong&gt;，不过会&lt;strong&gt;重定向&lt;/strong&gt;所有命令到systemctl工具。&lt;/p&gt;
&lt;p&gt;以http服务为例：&lt;br /&gt;
启动服务
&lt;code&gt;systemctl start httpd.service&lt;/code&gt;
停止服务
&lt;code&gt;systemctl stop httpd.service&lt;/code&gt;
重启服务（若服务正在运行，则重启；若服务停止，则启动）
&lt;code&gt;systemctl restart httpd.service&lt;/code&gt;
重启服务（若服务运行，则重启；停止，则无动作）
&lt;code&gt;systemctl try-start httpd.service&lt;/code&gt;
重新加载配置文件
&lt;code&gt;systemctl reload httpd.service&lt;/code&gt;
设置开机启动
&lt;code&gt;systemctl enable httpd.service&lt;/code&gt;
取消开机启动
&lt;code&gt;systemctl disable httpd.service&lt;/code&gt;
查看服务运行状态
&lt;code&gt;systemctl status httpd.service&lt;/code&gt;
&lt;img alt="status" src="http://roses-echo.com/images/linux-note-linux-operation-mechanism-and-using-systemd/5.png" /&gt;
查看http服务是否设置开机启动
&lt;code&gt;systemctl is-enabled httpd.service&lt;/code&gt;
&lt;img alt="status" src="http://roses-echo.com/images/linux-note-linux-operation-mechanism-and-using-systemd/6.png" /&gt;&lt;/p&gt;
&lt;p&gt;查看各个运行级别下所有服务的启用和禁用情况
&lt;code&gt;systemctl list-unit-files --type=service&lt;/code&gt;
&lt;img alt="status" src="http://roses-echo.com/images/linux-note-linux-operation-mechanism-and-using-systemd/7.png" /&gt;&lt;/p&gt;
&lt;p&gt;用systemctl管理电源：&lt;br /&gt;
关机
&lt;code&gt;systemctl poweroff&lt;/code&gt;
重启
&lt;code&gt;systemctl reboot&lt;/code&gt;
待机
&lt;code&gt;systemctl suspend&lt;/code&gt;
休眠
&lt;code&gt;systemctl hibernate&lt;/code&gt;
混合休眠
&lt;code&gt;systemctl hybrid-sleep&lt;/code&gt;&lt;/p&gt;</content><category term="Linux"></category><category term="CentOS"></category><category term="runlevel"></category></entry><entry><title>Linux学习笔记 - Shell简介</title><link href="http://roses-echo.com/articles/2017/Jan/26/linux-note-shell-intro/" rel="alternate"></link><published>2017-01-26T00:00:00+08:00</published><updated>2017-01-26T00:00:00+08:00</updated><author><name>Ro$es</name></author><id>tag:roses-echo.com,2017-01-26:/articles/2017/Jan/26/linux-note-shell-intro/</id><summary type="html">&lt;p&gt;想用好Linux，必须学会Shell的使用。&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;em&gt;参考资料：《循序渐进Linux第二版》&lt;/em&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;shell是围绕在Linux之外的一个“壳”程序，用户在操作系统上完成的所有任务都是通过shell和Linux系统内核的交互来实现的。&lt;br /&gt;
Linux下的shell有Bourne again shell (bash)[缺省] 、C shell (csh)、Korn shell (ksh)、Bourne shell (sh)和Tenex C shell (tcsh)等。  &lt;/p&gt;
&lt;p&gt;现在的Linux发行版一般都以&lt;strong&gt;bash&lt;/strong&gt;作为默认shell。&lt;/p&gt;
&lt;p&gt;shell本身是一个以C语言编写的程序，是&lt;strong&gt;用户和操作系统内核之间通信的桥梁&lt;/strong&gt;。shell既是一种命令解释程序，又是一种功能强大的解释型程序设计语言。作为命令解释程序，shell解释用户输入的命令，然后提交到内核处理，最后把结果返回给用户。&lt;/p&gt;
&lt;p&gt;为了加快命令的运行，同时更有效的定制shell程序，shell中定义了一些内置命令。&lt;br /&gt;
当用户登录系统后，shell以及内置命令就被系统载入到内存，并且一直运行，直到用户退出系统为止。&lt;br /&gt;
其他可执行文件与shell内置命令不同，当它们被调用时，才会被系统装入内存执行。  &lt;/p&gt;
&lt;p&gt;字符界面中，“#”表示登录的是系统超级用户，“*”表示登录到系统的是普通用户。&lt;/p&gt;
&lt;p&gt;shell执行命令解释过程：  &lt;/p&gt;
&lt;p&gt;&lt;img alt="shell" src="http://roses-echo.com/images/linux-note-shell-intro/1.png" /&gt;&lt;/p&gt;
&lt;h3&gt;shell命令的语法分析&lt;/h3&gt;
&lt;p&gt;对于一些普通的命令，各个shell版本的语法基本相同，只有在编写一个shell脚本或者使用一些shell高级特性的时候，各个版本的shell的差异才会显示出来。&lt;/p&gt;
&lt;p&gt;shell语法分析：shell对命令的扫描处理过程。&lt;br /&gt;
包括：重定向、文件名扩展和管道等。&lt;/p&gt;
&lt;p&gt;以bash为例 &lt;/p&gt;
&lt;p&gt;命令行格式  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;command [options] [arguments]
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;command  命令名称&lt;/li&gt;
&lt;li&gt;options      命令选项&lt;/li&gt;
&lt;li&gt;arguments 命令参数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在选项前一般有“-”符号，用于区别参数。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rm -rf /*
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;选项可以分开列，也可以单独列。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rm -r -f /*
或
rm -rf /*
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;有些命令不需要参数。若参数不够，则出现错误提示。&lt;/p&gt;
&lt;p&gt;&lt;img alt="shell" src="http://roses-echo.com/images/linux-note-shell-intro/2.png" /&gt;&lt;/p&gt;
&lt;p&gt;同一行可以多个命令，用“;”分开。&lt;/p&gt;
&lt;p&gt;&lt;img alt="shell" src="http://roses-echo.com/images/linux-note-shell-intro/3.png" /&gt;&lt;/p&gt;
&lt;p&gt;一个命令可以分行输入，用“\”分行。&lt;/p&gt;
&lt;p&gt;&lt;img alt="shell" src="http://roses-echo.com/images/linux-note-shell-intro/4.png" /&gt;&lt;/p&gt;
&lt;p&gt;通配符（可以组合使用）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;“*” 匹配任意一个或多个字符&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;“?” 匹配任意单一字符&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;“[]” 匹配方括号内所有的单个字符&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;shell的重定向&lt;/h3&gt;
&lt;p&gt;Linux下系统打开3个文件，即标准输入、标准输出和标准错误输出。
用户的shell将键盘设为默认的标准输入，默认的标准输出和标准错误输出为屏幕。&lt;/p&gt;
&lt;h4&gt;输入重定向&lt;/h4&gt;
&lt;p&gt;改变命令的输入源。利用输入重定向，可以将一个文件的内容作为命令的输入，而不从键盘输入。&lt;br /&gt;
操作符：&lt;code&gt;'&amp;lt;'  '&amp;lt;&amp;lt;'&lt;/code&gt;&lt;/p&gt;
&lt;h4&gt;输出重定向&lt;/h4&gt;
&lt;p&gt;将输出结果输出到一个指定文件中，而不是在屏幕。&lt;br /&gt;
操作符：&lt;code&gt;'&amp;gt;'  '&amp;gt;&amp;gt;'&lt;/code&gt;&lt;/p&gt;
&lt;h4&gt;错误重定向&lt;/h4&gt;
&lt;p&gt;与输出重定向类似。&lt;br /&gt;
操作符：&lt;code&gt;'2&amp;gt;'  '2&amp;gt;&amp;gt;'&lt;/code&gt;&lt;/p&gt;
&lt;h3&gt;shell的管道&lt;/h3&gt;
&lt;p&gt;管道可以把很多命令连接起来，可以把第一个命令的输入当作第二个命令的输出，第二个命令的输出当作第三个命令的输入，依此类推。&lt;br /&gt;
管道符：&lt;code&gt;'|'&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;查看系统中正在运行的httpd进程。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ps -ef | grep httpd
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="shell" src="http://roses-echo.com/images/linux-note-shell-intro/5.png" /&gt;&lt;/p&gt;
&lt;h3&gt;shell中的引用&lt;/h3&gt;
&lt;p&gt;引用即为通知shell将一些有特殊含义的字符当作普通字符处理。&lt;br /&gt;
转义字符&lt;code&gt;\&lt;/code&gt;，单引号&lt;code&gt;''&lt;/code&gt;，双引号&lt;code&gt;""&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;将文件“abc*?”重命名为“abc”&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mv abc\?\* abc
或
mv 'abc?*' abc
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;双引号用法与单引号基本相同，但某些特殊字符在&lt;strong&gt;双引号&lt;/strong&gt;中依然&lt;strong&gt;起作用&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img alt="shell" src="http://roses-echo.com/images/linux-note-shell-intro/6.png" /&gt;&lt;/p&gt;
&lt;p&gt;从图得知，&lt;code&gt;"$"&lt;/code&gt;,&lt;code&gt;"\"&lt;/code&gt; ,&lt;code&gt;"`"&lt;/code&gt; 在双引号中依然起作用。&lt;/p&gt;
&lt;p&gt;使用tab键可以自动补全。&lt;/p&gt;
&lt;p&gt;&lt;img alt="shell" src="http://roses-echo.com/images/linux-note-shell-intro/7.png" /&gt;&lt;/p&gt;</content><category term="Linux"></category><category term="CentOS"></category><category term="shell"></category></entry><entry><title>Linux学习笔记 - Linux外在设备的使用</title><link href="http://roses-echo.com/articles/2017/Jan/25/linux-note-external-equipment/" rel="alternate"></link><published>2017-01-25T00:00:00+08:00</published><updated>2017-01-25T00:00:00+08:00</updated><author><name>Ro$es</name></author><id>tag:roses-echo.com,2017-01-25:/articles/2017/Jan/25/linux-note-external-equipment/</id><summary type="html">&lt;p&gt;外在设备的介绍、挂载与使用。&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;em&gt;参考资料：《循序渐进Linux第二版》&lt;/em&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;在Linux系统下，设备都以文件的形式存在，因而不同硬件设备有不同的文件类型。&lt;br /&gt;
硬件与系统下相对应的文件称作设备文件。&lt;br /&gt;
设备文件在外部设备与操作系统之间提供了一个接口，这样，用户使用外在设备就相当于使用普通文件一样。&lt;br /&gt;
设备文件存放在/dev下。  &lt;/p&gt;
&lt;p&gt;软盘（floppydisk）：/dev/fdx（x为编号）&lt;br /&gt;
U盘（被识别为SCSI设备）：/dev/sdax（a为第一块SCSI设备，或者为b、c……；x为编号）&lt;br /&gt;
IDE光驱：/dev/had&lt;br /&gt;
SCSI光驱：/dev/srx（x为编号）&lt;br /&gt;
/dev/cdrom：一些发行版上有，是一个指向光驱的符号链接&lt;br /&gt;
SCSI磁盘（SCSI tape）：/dev/stx（x为编号）  &lt;/p&gt;
&lt;p&gt;常见文件类型&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th align="left"&gt;解释&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;msdos&lt;/td&gt;
&lt;td align="left"&gt;DOS文件系统类型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;vfat&lt;/td&gt;
&lt;td align="left"&gt;支持长文件名的DOS分区文件系统类型，也可以理解为Windows文件系统类型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;iso9660&lt;/td&gt;
&lt;td align="left"&gt;光盘格式文件系统类型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ext2/ext3/ext4&lt;/td&gt;
&lt;td align="left"&gt;Linux下的主流文件系统类型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;xfs&lt;/td&gt;
&lt;td align="left"&gt;Linux下一中高性能的日志文件系统，在CentOS7.x版本中成为默认文件系统&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</content><category term="Linux"></category><category term="CentOS"></category></entry><entry><title>Linux学习笔记 - Linux文件系统结构</title><link href="http://roses-echo.com/articles/2017/Jan/25/linux-note-file-system-structure/" rel="alternate"></link><published>2017-01-25T00:00:00+08:00</published><updated>2017-01-25T00:00:00+08:00</updated><author><name>Ro$es</name></author><id>tag:roses-echo.com,2017-01-25:/articles/2017/Jan/25/linux-note-file-system-structure/</id><summary type="html">&lt;p&gt;Linux文件系统结构的介绍。&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;em&gt;参考资料：《循序渐进Linux第二版》&lt;/em&gt; &lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;目录结构&lt;/h3&gt;
&lt;p&gt;Linux系统以树形结构统一管理和组织文件。  &lt;/p&gt;
&lt;p&gt;&lt;img alt="structure" src="http://roses-echo.com/images/linux-note-file-system-structure/1.png" /&gt;  &lt;/p&gt;
&lt;h3&gt;目录功能介绍&lt;/h3&gt;
&lt;p&gt;很多Linux发行版目录结构布局都遵循FSSTND标准。这一标准的特点是根目录非常简洁，只包含系统最基本的文件。  &lt;/p&gt;
&lt;h4&gt;/etc目录&lt;/h4&gt;
&lt;p&gt;主要用于存放系统管理相关的配置文件以及子目录，其中比较重要的有系统初始化文件/etc/rc、用户信息文件/etc/passwd等，相关网络配置文件和服务启动文件也在这个目录下。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;文件名和目录&lt;/th&gt;
&lt;th&gt;主要作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;passwd&lt;/td&gt;
&lt;td&gt;用户库文件、每个用户的用户名、UID、GID和工作目录等。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;shadow&lt;/td&gt;
&lt;td&gt;存放用户密码的文件，密码被加密储存&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;group&lt;/td&gt;
&lt;td&gt;主要存储用户组信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;fstab&lt;/td&gt;
&lt;td&gt;系统开机启动自动挂载分区列表，需要设置开机自动挂载的分区，都可以在此文件加入&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;systemd&lt;/td&gt;
&lt;td&gt;systemd的配置文件目录，是CentOS 7.x版本之后新增目录，此目录是Linux启动的重要部分，用来完成对整个系统的基本初始化设置&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;hosts&lt;/td&gt;
&lt;td&gt;IP与名字对应表，与Windows下的hosts文件类似&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;resolv.conf&lt;/td&gt;
&lt;td&gt;DNS配置文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;systemd/system/*.wants&lt;/td&gt;
&lt;td&gt;包含所有服务启动脚本，开机时自动启动这些服务，CentOS 7.x版本呢之后新增目录&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;sysconfig/network-scripts/ifcfg-eth0&lt;/td&gt;
&lt;td&gt;IP地址配置文件，CentOS 7.x之后网卡名从类似eth0,eth1变为enp0s3,enp0s4&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;X11&lt;/td&gt;
&lt;td&gt;X-Window的配置文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;rsyslog.conf&lt;/td&gt;
&lt;td&gt;系统日志输出配置文件，CentOS 5.x之前版本中对应为syslog.conf，6.x版本以后为rsyslog.conf&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;crontab&lt;/td&gt;
&lt;td&gt;系统级别的守护进程配置文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;sysctl.conf&lt;/td&gt;
&lt;td&gt;系统内核参数配置文件。在CentOS 7.x版本之后，内核参数配置文件转移到了/usr/lib/sysctl.d目录下，但sysctl.conf仍有效，并且可覆盖/usr/lib/sysctl.d中的配置&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;services&lt;/td&gt;
&lt;td&gt;定义系统服务与端口的对应关系&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;profile&lt;/td&gt;
&lt;td&gt;系统全局环境变量配置文件&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4&gt;/usr目录&lt;/h4&gt;
&lt;p&gt;主要存放应用程序和文件。软件包默认安装到此目录，所以一般比较大。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;文件或目录&lt;/th&gt;
&lt;th&gt;主要作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;lib64以及local/lib64&lt;/td&gt;
&lt;td&gt;64位操作系统中的函数库目录&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;src&lt;/td&gt;
&lt;td&gt;包含所有程序的源代码，其中主要是Linux核心程序源代码&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;local&lt;/td&gt;
&lt;td&gt;存放本地安装的软件和其他文件，与Linux无关&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;bin以及/local/bin&lt;/td&gt;
&lt;td&gt;使用者可执行的二进制文件目录&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;lib以及local/lib&lt;/td&gt;
&lt;td&gt;32位操作系统使用的函数库目录&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;sbin以及local/bin&lt;/td&gt;
&lt;td&gt;存放系统管理员才能执行的指令&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;include&lt;/td&gt;
&lt;td&gt;包含C语言的头文件，文件扩展名大多是.h&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;share&lt;/td&gt;
&lt;td&gt;存放共享的文件和数据库&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4&gt;/var目录&lt;/h4&gt;
&lt;p&gt;主要存放系统运行以及软件运行的日志信息。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;文件或目录&lt;/th&gt;
&lt;th&gt;主要作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;log&lt;/td&gt;
&lt;td&gt;存放各种应用程序的日志文件，这里的文件是经常变动的，因此需要定期清理&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;lib&lt;/td&gt;
&lt;td&gt;存放系统正常运行时需要改变的库文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;spool&lt;/td&gt;
&lt;td&gt;mail、new、打印机队列和其他队列输入、输出的缓冲目录&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;tmp&lt;/td&gt;
&lt;td&gt;允许比/tmp存放更大的文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;lock&lt;/td&gt;
&lt;td&gt;存放被锁定的文件，很多程序都会在/var/lock产生一个锁文件，以保证其他程序不能同时使用这个设备或文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;local&lt;/td&gt;
&lt;td&gt;存放/usr/local中所安装程序的可变数据&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;account&lt;/td&gt;
&lt;td&gt;存放已经格式化的man页&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;run&lt;/td&gt;
&lt;td&gt;包含到下次系统启动前的系统信息&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4&gt;/dev目录&lt;/h4&gt;
&lt;p&gt;包含系统所有的设备文件。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;设备名&lt;/th&gt;
&lt;th&gt;具体含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;fd*&lt;/td&gt;
&lt;td&gt;软盘设备，fd0为第一个，fd1为第二个，依此类推&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;audio*&lt;/td&gt;
&lt;td&gt;声卡设备&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;hd*&lt;/td&gt;
&lt;td&gt;IDE硬盘设备，hda代表第一个IDE硬盘，hdb代表第二个，依此类推&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;sd*&lt;/td&gt;
&lt;td&gt;SCSI设备，sda代表第一个SCSI硬盘，sdb代表第二个，依此类推&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;lp*&lt;/td&gt;
&lt;td&gt;并行串口&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;pty*&lt;/td&gt;
&lt;td&gt;网络中登录的远程终端设备&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ram*&lt;/td&gt;
&lt;td&gt;系统内存&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;tty*&lt;/td&gt;
&lt;td&gt;Linux上的虚拟控制台，也叫字符控制台。tty1代表第一个，tty2代表第二个，依此类推。Linux上一共有6个虚拟控制台。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ttyS*&lt;/td&gt;
&lt;td&gt;串行端口。ttys0代表串行端口1，ttys2代表串行端口2，类似于Windows下的COM1，COM2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;console&lt;/td&gt;
&lt;td&gt;系统控制台，可以直接连接到显示器&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;null&lt;/td&gt;
&lt;td&gt;输出空设备&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4&gt;/proc目录&lt;/h4&gt;
&lt;p&gt;一个虚拟目录，目录中所信息都是内存的映射，通过这个虚拟的内存映射目录，可以和内核内部数据进行交互，获取有关进程的有用信息，同时也可以在系统运行中修改内核参数。与其他目录不用，/proc存在于内存中，而不是硬盘上。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;文件或目录&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;cpuinfo&lt;/td&gt;
&lt;td&gt;关于系统CPU的详细信息，包括CPU名称、型号和类型等&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;meninfo&lt;/td&gt;
&lt;td&gt;内存信息，包括物理内存和虚拟内存&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;filesystems&lt;/td&gt;
&lt;td&gt;当前系统支持的文件系统类型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;devices&lt;/td&gt;
&lt;td&gt;内核中设备驱动程序列表&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;net&lt;/td&gt;
&lt;td&gt;网络使用协议以及状态信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;dma&lt;/td&gt;
&lt;td&gt;当前使用的dma通道&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ioports&lt;/td&gt;
&lt;td&gt;当前使用的I/O端口&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;modules                                 当前系统系统加载的内核模块信息&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;stat&lt;/td&gt;
&lt;td&gt;系统的各种状态信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;uptime&lt;/td&gt;
&lt;td&gt;系统总的启动时间和空闲时间，以秒为单位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;version&lt;/td&gt;
&lt;td&gt;内核版本信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;loadavg&lt;/td&gt;
&lt;td&gt;系统平均负载&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;kcore&lt;/td&gt;
&lt;td&gt;系统物理内存的映像，与物理内存大小完全一样，但实际不占用这么大的空间&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;kmsg&lt;/td&gt;
&lt;td&gt;内核输出信息，同时被输出到rsyslog&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4&gt;其他目录&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;目录&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;/boot&lt;/td&gt;
&lt;td&gt;启动Linux时的一些核心文件，具体包含一些镜像文件和链接文件，因此这个目录非常重要，如果遭到破坏，系统将无法启动。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/bin&lt;/td&gt;
&lt;td&gt;用户可以执行的二进制文件。（普通命令）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/sbin&lt;/td&gt;
&lt;td&gt;root用户才能执行的二进制文件。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/home&lt;/td&gt;
&lt;td&gt;每个用户的工作目录。如A用户的默认工作目录为/home/A&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/lib&lt;/td&gt;
&lt;td&gt;共享程序库和映像文件，可供很多程序使用。通过这些共享映射文件，每个程序就不必分别保存自己的库文件（这会增加占用的磁盘空间），Linux提供了一组可供所有程序使用的文件。在该目录中，还包含引导进程所需的静态库文件。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/root&lt;/td&gt;
&lt;td&gt;Linux超级用户root的默认主目录。如果通过root登录系统，就会自动进入此目录，一般用户没有进入这个目录的权限。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/run&lt;/td&gt;
&lt;td&gt;外在设备的自动挂载点目录，出现在CentOS 7.x版本中，用来自动挂载光驱和U盘。另外还有/media目录，与/run作用基本类似，在7.x之前版本中使用。还有一个/mnt用来手动挂载一些移动设备，比如可移动磁盘等。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/lost+found&lt;/td&gt;
&lt;td&gt;用于保存丢失的文件。不恰当的关机操作和磁盘错误均会导致文件丢失。这些会丢失的文件会临时放在/lost+found下，系统重启后，引导进程会运行fsck程序，该程序就能发现这些文件。除了“/”分区上的这个目录外，在每个分区上均有一个lost+found目录。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/tmp&lt;/td&gt;
&lt;td&gt;临时文件目录。里面的文件可以随时删除。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</content><category term="Linux"></category><category term="CentOS"></category></entry><entry><title>Linux学习笔记 - Linux硬件资源管理</title><link href="http://roses-echo.com/articles/2017/Jan/25/linux-note-hardware-managing/" rel="alternate"></link><published>2017-01-25T00:00:00+08:00</published><updated>2017-01-25T00:00:00+08:00</updated><author><name>Ro$es</name></author><id>tag:roses-echo.com,2017-01-25:/articles/2017/Jan/25/linux-note-hardware-managing/</id><summary type="html">&lt;p&gt;Linux下的硬件管理介绍。&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;em&gt;参考资料：《循序渐进Linux第二版》&lt;/em&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;列出所有的PCI设备&lt;br /&gt;
&lt;code&gt;lspci&lt;/code&gt;
&lt;img alt="lspci" src="http://roses-echo.com/images/linux-note-hardware-managing/1.png" /&gt;&lt;br /&gt;
&lt;img alt="lspci" src="http://roses-echo.com/images/linux-note-hardware-managing/2.png" /&gt;&lt;/p&gt;
&lt;p&gt;查看cpu信息
&lt;code&gt;more /proc/cpuinfo&lt;/code&gt;
&lt;img alt="lspci" src="http://roses-echo.com/images/linux-note-hardware-managing/3.png" /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;processor -- 逻辑处理器的唯一标识符&lt;/li&gt;
&lt;li&gt;vendor-id -- 处理器类型&lt;/li&gt;
&lt;li&gt;physical id -- 每个物理封装的唯一标识符&lt;/li&gt;
&lt;li&gt;siblings -- 位于相同物理封装中的逻辑处理器的数量&lt;/li&gt;
&lt;li&gt;core id  -- 每个内核的唯一标识符&lt;/li&gt;
&lt;li&gt;cpu cores -- 位于相同物理封装中的内核数量&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;若siblings是cpu cores的两倍，则说明系统支持超线程，而且超线程已打开；如果siblings和cpu cores一致，则说明系统不支持超线程，或者超线程未打开。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;查看系统物理CPU的个数
&lt;code&gt;cat /proc/cpuinfo | grep "physical id" | sort | uniq | wc -l&lt;/code&gt;
&lt;img alt="lspci" src="http://roses-echo.com/images/linux-note-hardware-managing/4.png" /&gt;  &lt;/p&gt;
&lt;p&gt;查看每个物理CPU中内核的个数
&lt;code&gt;cat /proc/cpuinfo | grep "cpu cores"&lt;/code&gt;
&lt;img alt="lspci" src="http://roses-echo.com/images/linux-note-hardware-managing/5.png" /&gt;&lt;/p&gt;
&lt;p&gt;查看系统所有逻辑CPU个数（所有物理CPU中内核的个数加上超线程个数）
&lt;code&gt;cat /proc/cpuinfo | grep "processor" | wc -l&lt;/code&gt;
&lt;img alt="lspci" src="http://roses-echo.com/images/linux-note-hardware-managing/6.png" /&gt;&lt;/p&gt;
&lt;p&gt;可以得出：有2个物理CPU，每个CPU1个内核，没启用超线程，总共2个逻辑CPU。  &lt;/p&gt;
&lt;p&gt;查看内存信息
&lt;code&gt;more /proc/meminfo&lt;/code&gt;
&lt;img alt="lspci" src="http://roses-echo.com/images/linux-note-hardware-managing/7.png" /&gt;&lt;/p&gt;
&lt;p&gt;查看磁盘分区信息
&lt;code&gt;fdisk -l&lt;/code&gt;
&lt;img alt="lspci" src="http://roses-echo.com/images/linux-note-hardware-managing/8.png" /&gt;&lt;/p&gt;</content><category term="Linux"></category><category term="Hardware"></category></entry><entry><title>Linux学习笔记 - Linux下设备挂载命令以及NTFS格式U盘的挂载</title><link href="http://roses-echo.com/articles/2017/Jan/25/linux-note-mount-and-mount-ntfs-udisk/" rel="alternate"></link><published>2017-01-25T00:00:00+08:00</published><updated>2017-01-25T00:00:00+08:00</updated><author><name>Ro$es</name></author><id>tag:roses-echo.com,2017-01-25:/articles/2017/Jan/25/linux-note-mount-and-mount-ntfs-udisk/</id><summary type="html">&lt;p&gt;mount 和 umount的使用以及NTFS格式U盘在Linux上的使用。&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;em&gt;参考资料：《循序渐进Linux第二版》&lt;/em&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Linux系统中，使用mount命令进行设备的挂载使用。&lt;br /&gt;
&lt;code&gt;mount -t 文件系统类型设备名挂载点&lt;/code&gt;
/mnt目录专门用作临时挂载点&lt;br /&gt;
在&lt;strong&gt;&lt;em&gt;*CentOS 7.x&lt;/em&gt;&lt;/strong&gt;*中，出现了一个/run自动挂在目录，所有移动设备会自动挂在到这个目录下  &lt;/p&gt;
&lt;p&gt;挂载软盘
&lt;code&gt;mount -t msdos/dev/fd0 /mnt/floppy&lt;/code&gt;
访问/mnt/floppy即可找到软盘内容。&lt;/p&gt;
&lt;h5&gt;U盘的挂载&lt;/h5&gt;
&lt;p&gt;插入U盘后，可以先使用&lt;code&gt;dmesg&lt;/code&gt;命令确定U盘的设备名。&lt;br /&gt;
&lt;img alt="dmesg" src="http://roses-echo.com/images/linux-note-mount-and-mount-ntfs-udisk/1.png" /&gt;  &lt;/p&gt;
&lt;p&gt;可以得出U盘设备名为sdb1  &lt;/p&gt;
&lt;p&gt;使用fdisk -l 同样可以查看U盘是否被识别。&lt;br /&gt;
&lt;img alt="fdisk" src="http://roses-echo.com/images/linux-note-mount-and-mount-ntfs-udisk/2.png" /&gt;  &lt;/p&gt;
&lt;p&gt;接着创建挂载点：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mkdir /mnt/usb&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;然后挂载U盘： &lt;/p&gt;
&lt;p&gt;&lt;code&gt;mount  /dev/sdb1 /mnt/usb&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="mount" src="http://roses-echo.com/images/linux-note-mount-and-mount-ntfs-udisk/3.png" /&gt;  &lt;/p&gt;
&lt;p&gt;Linux系统不支持NTFS格式。此时需要使用插件ntfs-3g。&lt;/p&gt;
&lt;p&gt;官网：&lt;a href="http://www.tuxera.com/community/open-source-ntfs-3g/"&gt;ntfs-3g&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="ntfs-3g" src="http://roses-echo.com/images/linux-note-mount-and-mount-ntfs-udisk/4.png" /&gt;  &lt;/p&gt;
&lt;p&gt;下载压缩包：
&lt;code&gt;wget https://tuxera.com/opensource/ntfs-3g_ntfsprogs-2016.2.22.tgz&lt;/code&gt;
&lt;img alt="wget" src="http://roses-echo.com/images/linux-note-mount-and-mount-ntfs-udisk/5.png" /&gt;  &lt;/p&gt;
&lt;p&gt;解压压缩包
&lt;code&gt;tar -zvxf ntfs-3g_ntfsprogs-2016.2.22.tgz&lt;/code&gt;
&lt;img alt="tar" src="http://roses-echo.com/images/linux-note-mount-and-mount-ntfs-udisk/6.png" /&gt;  &lt;/p&gt;
&lt;p&gt;转到ntfs-3g的目录下
&lt;code&gt;cd ntfs-3g_ntfsprogs-2016.2.22&lt;/code&gt;
在/usr/local/下创建文件夹ntfs-3g，用于编译安装
&lt;code&gt;mkdir /usr/local/ntfs-3g&lt;/code&gt;
编译安装ntfs-3g，指定安装目录/usr/local/ntfs-3g
&lt;code&gt;./configure --prefix=/usr/local/ntfs-3g&lt;/code&gt;
&lt;img alt="config" src="http://roses-echo.com/images/linux-note-mount-and-mount-ntfs-udisk/7.png" /&gt;   &lt;/p&gt;
&lt;p&gt;开始编译
&lt;code&gt;make &amp;amp;&amp;amp; make install&lt;/code&gt;
编译成功后，就可以挂在NTFS格式的U盘了。
&lt;code&gt;mount -t ntfs-3g /dev/sdb1 /mnt/usb&lt;/code&gt;
&lt;img alt="mount" src="http://roses-echo.com/images/linux-note-mount-and-mount-ntfs-udisk/8.png" /&gt;  &lt;/p&gt;
&lt;p&gt;查看U盘内容
&lt;code&gt;cd /mnt/usb
ls&lt;/code&gt;
&lt;img alt="ls" src="http://roses-echo.com/images/linux-note-mount-and-mount-ntfs-udisk/9.png" /&gt;  &lt;/p&gt;
&lt;h5&gt;卸载设备&lt;/h5&gt;
&lt;p&gt;umount 挂载目录
&lt;code&gt;umount /mnt/usb&lt;/code&gt;
&lt;img alt="umount" src="http://roses-echo.com/images/linux-note-mount-and-mount-ntfs-udisk/10.png" /&gt;  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Linux对文件系统的保护做的很到位，在光盘没有卸载之前，光驱上的弹出键不起任何作用。&lt;/strong&gt;&lt;/p&gt;</content><category term="Linux"></category><category term="CentOS"></category><category term="NTFS"></category><category term="mount"></category></entry><entry><title>Linux学习笔记 - Linux系统的安装与基础配置</title><link href="http://roses-echo.com/articles/2017/Jan/23/linux-note-os-install-and-basic-config/" rel="alternate"></link><published>2017-01-23T00:00:00+08:00</published><updated>2017-01-23T00:00:00+08:00</updated><author><name>Ro$es</name></author><id>tag:roses-echo.com,2017-01-23:/articles/2017/Jan/23/linux-note-os-install-and-basic-config/</id><summary type="html">&lt;p&gt;安装Linux与简单配置。&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;em&gt;参考资料：《循序渐进Linux第二版》&lt;/em&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;安装方式&lt;/h3&gt;
&lt;p&gt;Linux的安装方式分为硬盘安装、U盘安装、网络安装和光驱安装。&lt;br /&gt;
可以使用Kickstart工具进行无人值守的Linux系统自动安装。&lt;/p&gt;
&lt;h3&gt;分区命名方案&lt;/h3&gt;
&lt;p&gt;/dev/hda2&lt;br /&gt;
/dev/sdb3&lt;br /&gt;
/dev ：所有设备文件的存放目录&lt;br /&gt;
hd和sd：分区的前两个字母，代表该分区所在的设备类型。hd代表IDE硬盘，sd代表SCSI硬盘。&lt;br /&gt;
a：分区命名的第三个字母，表示分区在哪个设备上。/dev/hda 代表第1块IDE硬盘，/dev/sdb代表第2块SCSI硬盘。&lt;br /&gt;
2：数字代表分区。Linux下前4个分区（主分区或扩展分区）用数字1~4表示，逻辑分区从5开始。/dev/sdb3代表第2块SCSI硬盘的第3个主分区或扩展分区。/dev/sdc6代表第3块SCSI硬盘的第2个逻辑分区。  &lt;/p&gt;
&lt;h3&gt;Windows+Linux双系统注意事项&lt;/h3&gt;
&lt;p&gt;两种系统的文件系统不兼容。要从Windows系统完全删除分区，余出空间，从而安装Linux。&lt;br /&gt;
最好先安装Windows。因为每次安装Windows都会重新修改系统引导文件。安装Windows后Linux可能会没引导。  &lt;/p&gt;
&lt;h3&gt;CentOS安装过程中的Troubleshooting模式&lt;/h3&gt;
&lt;p&gt;Troubleshooting 主要用于帮助解决各种安装问题以及对系统的故障修复。&lt;br /&gt;
Troubleshooting中的各个选项：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;图形模式下安装CentOS&lt;/li&gt;
&lt;li&gt;救援CentOS模式（最常用）（可用于系统内核问题、配置文件错误、磁盘错误等造成系统无法启动时的故障修复）&lt;/li&gt;
&lt;li&gt;内存测试&lt;/li&gt;
&lt;li&gt;从本地驱动器启动&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Linux安装中的一些注意事项&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;对于Linux服务器来说，安全是第一位的，需要什么就安装什么，不需要的一定不要安装，多余的软件不但占用磁盘空间，而且会给服务器带来潜在的安全隐患。因此，当Linux作为一个服务器来使用时，要遵循按需安装、不用不装的原则。&lt;/strong&gt;比如，要搭建一个DNS服务器，仅仅需要安装DNS软件包和一个基础系统内核即可。&lt;strong&gt;这样可以最大限度地提高系统效率和保障系统安全。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Linux系统下必须的分区为根分区（用“/”标识）和交换分区（swap）。&lt;br /&gt;
swap分区相当于Windows中虚拟内存的概念，也就是内存数据与硬盘的交换。&lt;br /&gt;
swap分区大小基本原则：如果内存较小（例如物理内存小于4GB），一般设置swap分区大小为物理内存的2倍；如果大于4GB而小于16GB，可以设置swap分区大小等于物理内存；如果内存大小在16GB以上，可以设置swap分区大小为0。但并不建议设置为0，一定大小的swap分区还是有作用的。&lt;/p&gt;
&lt;p&gt;只划分根分区和swap分区可以完成安装但不建议。一旦根分区遭到破坏，系统无法启动，根分区中资料也可能丢失。建议给独立的应用分配独立的分区，能最大限度减少系统崩溃造成的损失。   &lt;/p&gt;
&lt;p&gt;建议独立分配的分区：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;/boot：存储系统的引导信息和内核等信息&lt;/li&gt;
&lt;li&gt;/usr：存储系统应用软件安装信息&lt;/li&gt;
&lt;li&gt;/var：存储系统日志信息&lt;/li&gt;
&lt;/ul&gt;</content><category term="Linux"></category><category term="CentOS"></category></entry><entry><title>《幕后玩家》有意思的台词</title><link href="http://roses-echo.com/articles/2016/Dec/23/words-in-Two-Steps-From-Heaven/" rel="alternate"></link><published>2016-12-23T00:00:00+08:00</published><updated>2016-12-23T00:00:00+08:00</updated><author><name>Ro$es</name></author><id>tag:roses-echo.com,2016-12-23:/articles/2016/Dec/23/words-in-Two-Steps-From-Heaven/</id><summary type="html">&lt;p&gt;当我可以放下面子去赚钱，就代表我懂事；&lt;br /&gt;
当我可以用钱买回面子，就是我成功了；&lt;br /&gt;
到我可以用面子赚钱的时候 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;当我可以放下面子去赚钱，就代表我懂事；&lt;br /&gt;
当我可以用钱买回面子，就是我成功了；&lt;br /&gt;
到我可以用面子赚钱的时候，我已经是一个人物了。&lt;br /&gt;
如果我还停留在喝酒吹水，不懂装懂，凡事都要讲面子，我这辈子，只不过是不外如是。  &lt;/p&gt;
&lt;p&gt;--人生真是无常。&lt;br /&gt;
--无常才是恒常。&lt;/p&gt;</content></entry><entry><title>一次过安全狗和360的渗透加提权过程</title><link href="http://roses-echo.com/articles/2016/Sep/20/bypass-360-and-safedog-privilege-escalation/" rel="alternate"></link><published>2016-09-20T00:00:00+08:00</published><updated>2016-09-20T00:00:00+08:00</updated><author><name>Ro$es</name></author><id>tag:roses-echo.com,2016-09-20:/articles/2016/Sep/20/bypass-360-and-safedog-privilege-escalation/</id><summary type="html">&lt;p&gt;用PDF记录了。&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;a href="http://roses-echo.com/pdfs/一次过安全狗和360的渗透加提权过程 - Ro$es.pdf"&gt;一次过安全狗和360的渗透加提权过程 - Ro$es.pdf&lt;/a&gt;&lt;/p&gt;</content><category term="360"></category><category term="安全狗"></category><category term="渗透"></category><category term="提权"></category></entry></feed>